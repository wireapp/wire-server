syntax = "proto3";
package wire.federator;

// These definitions are part of the federation protocol.
//
// A component (e.g. 'brig') will send some data of type 'RemoteCall' to
// the local 'federator' service. That federator will extract the domain from
// the 'RemoteCall' to discover where to send some data of type 'LocalCall' to.
// On the other end, the 'LocalCall' will be converted to a 'Response'.

enum Component {
  Brig = 0;
}

message HTTPResponse {
    uint32 responseStatus = 1;
    bytes responseBody = 2;
}

message Response {
  oneof response {
    HTTPResponse httpResponse = 1;
    string err = 2;
  }
}

// the envelope thing which is sent from brig to local federator
message RemoteCall {
  string domain = 1;
  LocalCall localCall = 2;
}

// the federator will take out LocalCall from the RemoteCall Envelope, and
// forward the LocalCall object to a federator on another backend (with the wish
// that this remote federator forwards this to its own local brig)
message LocalCall {
  Component component = 1;
  Method method = 2;
  bytes path = 3;
  repeated QueryParam query = 4;
  bytes body = 5;
}

message QueryParam {
  bytes key = 1;
  bytes value = 2;
}

enum Method {
  GET = 0;
  POST = 1;
  HEAD = 2;
  PUT = 3;
  DELETE = 4;
  TRACE = 5;
  CONNECT = 6;
  OPTIONS = 7;
  PATCH = 8;
}

// The * part of the following network traffic:
// brig *-> federator -> federator -> brig
// FUTUREWORK(federation): better naming?
service RouteToRemote {
  rpc call (RemoteCall) returns (Response);
}

// The * part of the following network traffic:
// Brig -> federator *-> federator -> brig
// FUTUREWORK(federation): better naming?
service RouteToInternal {
    // callLocal in haskell
  rpc call (LocalCall) returns (Response);
}
