#!/usr/bin/env python3

from dataclasses import dataclass
import os
import select
import signal
import shutil
import socket
import subprocess
import yaml
import urllib.request
import urllib.error
import sys
import time
import threading
import logging

class Colors:
    GREEN = "\x1b[38;5;10m"
    YELLOW = "\x1b[38;5;11m"
    BLUE = "\x1b[38;5;6m"
    PURPLEISH = "\x1b[38;5;13m"
    ORANGE = "\x1b[38;5;3m"
    RED = "\x1b[38;5;1m"
    RESET = "\x1b[0m"

@dataclass(frozen=True)
class Service:
    name: str
    color: str
    _internal_name: str = None
    check_status: bool = True

    @property
    def internal_name(self):
        if self._internal_name is None:
            return self.name
        else:
            return self._internal_name
    
    def path(self):
        return os.path.join(ROOT, "dist", self.name)

    def config_file(self):
        return os.path.join(ROOT, "services", self.name,
                            self.name + ".integration.yaml")

    def modified_config_file(self, service_map):
        """Overwrite port configuration on this service using the provided
        service_map.

        This works by creating an unnamed pipe, writing the modified config
        file to it, and returning a path to the read end of the pipe (in
        /proc)."""
        (r, w) = os.pipe()

        with open(self.config_file()) as f:
            data = yaml.safe_load(f)

        for service, port in service_map.items():
            if service.internal_name in data:
                data[service.internal_name]['port'] = port

        out = os.fdopen(w, 'w')
        yaml.dump(data, out)

        return f"/proc/{os.getpid()}/fd/{r}"

    def spawn(self, service_map, environment):
        config_file = self.modified_config_file(service_map)
        return subprocess.Popen([self.path(), "-c", config_file],
                               encoding='utf-8',
                               cwd=os.path.join(ROOT, "services", self.name),
                               env=environment,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT)

    def check_exists(self):
        if not os.path.exists(self.path()):
            raise Exception(f"{self.name} not found")

@dataclass(frozen=True)
class Nginz:
    color: str

    @property
    def name(self): return "nginz"

    @property
    def internal_name(self): return self.name

    @property
    def check_status(self): return True

    def spawn(self, service_map, environment):
        cwd = os.path.join(ROOT, "services", "nginz", "integration-test")
        return subprocess.Popen([shutil.which("nginx"), "-p", cwd, "-c",
                                os.path.join(cwd, "conf", "nginz","nginx.conf"),
                                "-g", "daemon off;"],
                                encoding='utf-8', cwd=cwd, env=environment,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)

    def check_exists(self):
        if shutil.which("nginx") is None:
            raise Exception("nginx not found")

@dataclass(frozen=True)
class Instance:
    service: Service
    thread: threading.Thread
    process: subprocess.Popen

def check_prerequisites(services):
    try:
        for port in (9042, 9200, 6379):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect(("127.0.0.1", port))
    except Exception as e:
        logging.error(f"{Colors.RED}Databases not up. Try running 'deploy/dockerephemeral/run.sh'. {Colors.RESET}")
        sys.exit(1)

    try:
        for service in services:
            service.check_exists()
    except Exception as e:
        logging.error(Colors.RED + str(e) + Colors.RESET)
        sys.exit(1)

def check_status(sub, port, service):
    sub.poll()
    if sub.returncode is not None:
        raise Exception(f"{service.name} has terminated")
    if not service.check_status:
        return True
    try:
        with urllib.request.urlopen(f"http://localhost:{port}/i/status") as resp:
            return resp.status in [200, 204]
    except urllib.error.URLError:
        return False

def color_output(sub, service):
    try:
        for line in sub.stdout:
            logging.info(f"{service.color}[{service.name}] {line.rstrip()}{Colors.RESET}")
    finally:
        sub.terminate()
        sub.wait()

def find_root(base):
    # find git repository
    root = os.path.realpath(base)
    while not os.path.exists(os.path.join(root, ".git")):
        p = os.path.dirname(root)
        if p == root: raise Exception("Could not find wire-server root")
        root = p
    return root

BRIG = Service("brig", Colors.GREEN)
GALLEY = Service("galley", Colors.YELLOW)
GUNDECK = Service("gundeck", Colors.BLUE)
CANNON = Service("cannon", Colors.ORANGE)
CARGOHOLD = Service("cargohold", Colors.PURPLEISH)
SPAR = Service("spar", Colors.ORANGE)
FEDERATOR = Service("federator", Colors.BLUE,
                    "federatorInternal", check_status=False)
STERN = Service("stern", Colors.YELLOW)
NGINZ = Nginz(Colors.PURPLEISH)

if __name__ == '__main__':
    logging.basicConfig(encoding='utf-8', level=logging.INFO,
                        format='%(message)s')
    ROOT = find_root(os.getcwd())
    if ROOT is None:
        error("This script needs to be run within the wire-server direnv")

    environment = {
        'AWS_REGION': "eu-west-1",
        'AWS_ACCESS_KEY_ID': "dummykey",
        'AWS_SECRET_ACCESS_KEY': "dummysecret"
    }

    instances = {
        CANNON: 2
    }
    service_map = {
        BRIG: 8082,
        GALLEY: 8085,
        GUNDECK: 8086,
        CANNON: 8083,
        CARGOHOLD: 8084,
        SPAR: 8088,
        FEDERATOR: 8097,
        NGINZ: 8080
    }
    check_prerequisites(service_map)

    instances = set()
    try:
        for service in service_map.keys():
            sub = service.spawn(service_map, environment)
            t = threading.Thread(target=lambda: color_output(sub, service))
            t.start()
            instance = Instance(service, t, sub)
            instances.add(instance)

        # check status
        to_be_checked = set(instances)
        while to_be_checked:
            instance = next(iter(to_be_checked))
            if check_status(instance.process,
                            service_map[instance.service],
                            instance.service):
                to_be_checked.remove(instance)

        # main script
        ret = subprocess.run(sys.argv[1:])
        sys.exit(ret.returncode)
    except KeyboardInterrupt:
        pass
    finally:
        for instance in instances:
            instance.process.terminate()

        for instance in instances:
            instance.thread.join(timeout=0.1)
            # some services don't react promptly to SIGTERM, so we give them a
            # nudge if they don't terminate within a few milliseconds
            if instance.thread.is_alive():
                instance.process.terminate()
                instance.thread.join()
