#!/usr/bin/env python3

from dataclasses import dataclass
import os
import re
import select
import signal
import shutil
import socket
import subprocess
import yaml
import urllib.request
import urllib.error
import sys
import tempfile
import time
import threading
import logging

class Colors:
    GREEN = "\x1b[38;5;10m"
    YELLOW = "\x1b[38;5;11m"
    BLUE = "\x1b[38;5;6m"
    PURPLEISH = "\x1b[38;5;13m"
    ORANGE = "\x1b[38;5;3m"
    RED = "\x1b[38;5;1m"
    RESET = "\x1b[0m"

@dataclass(frozen=True)
class Service:
    name: str
    color: str
    _internal_name: str = None
    check_status: bool = True

    @property
    def internal_name(self):
        if self._internal_name is None:
            return self.name
        else:
            return self._internal_name
    
    def path(self):
        return os.path.join(ROOT, "dist", self.name)

    def config_file(self):
        return os.path.join(ROOT, "services", self.name,
                            self.name + ".integration.yaml")


    def spawn(self, config_file, environment):
        print('spawn', self.name, config_file)
        return subprocess.Popen([self.path(), "-c", config_file],
                               encoding='utf-8',
                               cwd=os.path.join(ROOT, "services", self.name),
                               env=environment,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT)

    def check_exists(self):
        if not os.path.exists(self.path()):
            raise Exception(f"{self.name} not found")

@dataclass(frozen=True)
class Nginz:
    color: str

    @property
    def name(self): return "nginz"

    @property
    def internal_name(self): return self.name

    @property
    def check_status(self): return True

    def config_file(self):
        return os.path.join(ROOT, "services", "nginz", "integration-test",
                            "conf", "nginz","nginx.conf")

    def spawn(self, config_file, environment):
        cwd = os.path.join(ROOT, "services", "nginz", "integration-test")
        print(cwd)
        return subprocess.Popen([shutil.which("nginx"), "-p", cwd, "-c",
                                config_file,
                                "-g", "daemon off;"],
                                encoding='utf-8', cwd=cwd, env=environment,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)

    def check_exists(self):
        if shutil.which("nginx") is None:
            raise Exception("nginx not found")

@dataclass(frozen=True)
class Instance:
    service: Service
    port: int
    thread: threading.Thread = None
    process: subprocess.Popen = None

    def check_status(self):
        self.process.poll()
        if self.process.returncode is not None:
            raise Exception(f"{self.service.name} has terminated")
        if not self.service.check_status:
            return True
        try:
            with urllib.request.urlopen(f"http://localhost:{self.port}/i/status") as resp:
                return resp.status in [200, 204]
        except urllib.error.URLError:
            return False

    def spawn(self, service_map, environment):
        config_file = self.modified_config_file(service_map)
        sub = self.service.spawn(config_file, environment)
        t = threading.Thread(target=lambda: color_output(sub, self.service))
        t.start()
        return Instance(self.service, self.port, t, sub)

    def modified_config_file(self, service_map):
        """Overwrite port configuration on this service using the provided
        service_map.

        This works by creating an unnamed pipe, writing the modified config
        file to it, and returning a path to the read end of the pipe (in
        /proc)."""

        def get_port(service):
            if service is self.service:
                return self.port
            else:
                return service_map[service]

        with open(self.service.config_file()) as f:
            data = yaml.safe_load(f)

        for service in service_map:
            if service.internal_name in data:
                data[service.internal_name]['port'] = get_port(service)
        self.set_own_port(data)

        # write modified config file to pipe
        return make_pipe(yaml.dump(data).encode('utf-8'))

    def set_own_port(self, data):
        # spar's own port is in a different place
        if 'saml' in data:
            data['saml']['spPort'] = self.port

class FederatorInstance(Instance):
    def __init__(self, internal_port, external_port):
        self.external_port = external_port
        super().__init__(FEDERATOR, internal_port)

    def set_own_port(self, data):
        # set external port only, as the internal one is part of the service
        # map and is set by the general config logic
        data['federatorExternal']['port'] = self.external_port

class NginzInstance(Instance):
    def __init__(self, local_port, http2_port, ssl_port):
        self.http2_port = http2_port
        self.ssl_port = ssl_port
        self.temp_files = []
        super().__init__(NGINZ, local_port)

    def modified_config_file(self, service_map):
        override = f"""
            listen {self.port};
            listen {self.http2_port} http2;
            listen {self.ssl_port} ssl http2;
            listen [::]:{self.ssl_port} ssl http2;"""
        override_file = tempfile.NamedTemporaryFile()
        self.temp_files.append(override_file)
        override_file.write(override.encode('utf-8'))
        override_file.flush()

        config = open(self.service.config_file()).read()
        config = re.sub(r'^include integration.default.conf;$',
                        f"include {override_file}", 
                        config, re.MULTILINE)
        config_file = tempfile.NamedTemporaryFile()
        self.temp_files.append(config_file)
        config_file.write(config.encode('utf-8'))
        config_file.flush()

        return config_file.name

def check_prerequisites(services):
    try:
        for port in (9042, 9200, 6379):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect(("127.0.0.1", port))
    except Exception as e:
        logging.error(f"{Colors.RED}Databases not up. Try running 'deploy/dockerephemeral/run.sh'. {Colors.RESET}")
        sys.exit(1)

    try:
        for service in services:
            service.check_exists()
    except Exception as e:
        logging.error(Colors.RED + str(e) + Colors.RESET)
        sys.exit(1)

def color_output(sub, service):
    try:
        for line in sub.stdout:
            logging.info(f"{service.color}[{service.name}] {line.rstrip()}{Colors.RESET}")
    finally:
        sub.terminate()
        sub.wait()

def find_root(base):
    # find git repository
    root = os.path.realpath(base)
    while not os.path.exists(os.path.join(root, ".git")):
        p = os.path.dirname(root)
        if p == root: raise Exception("Could not find wire-server root")
        root = p
    return root

def make_pipe(data):
    (r, w) = os.pipe()
    os.write(w, data)
    os.close(w)
    return f"/proc/{os.getpid()}/fd/{r}"

BRIG = Service("brig", Colors.GREEN)
GALLEY = Service("galley", Colors.YELLOW)
GUNDECK = Service("gundeck", Colors.BLUE)
CANNON = Service("cannon", Colors.ORANGE)
CARGOHOLD = Service("cargohold", Colors.PURPLEISH)
SPAR = Service("spar", Colors.ORANGE)
FEDERATOR = Service("federator", Colors.BLUE,
                    "federatorInternal", check_status=False)
STERN = Service("stern", Colors.YELLOW)
NGINZ = Nginz(Colors.PURPLEISH)

def start_backend(services):
    # build a service map by choosing an arbitrary instance of each service
    service_map = dict((s.service, s.port) for s in services)

    instances = set()
    for blueprint in services:
        instances.add(blueprint.spawn(service_map, environment))

    # check status
    # TODO: global timeout
    to_be_checked = set(instances)
    while to_be_checked:
        instance = next(iter(to_be_checked))
        print("checking status", instance.service.name)
        if instance.check_status():
            to_be_checked.remove(instance)
        else:
            time.sleep(0.1)

    print("---- backend started ----")
    return instances

if __name__ == '__main__':
    logging.basicConfig(encoding='utf-8', level=logging.INFO,
                        format='%(message)s')
    ROOT = find_root(os.getcwd())
    if ROOT is None:
        error("This script needs to be run within the wire-server direnv")

    environment = {
        'AWS_REGION': "eu-west-1",
        'AWS_ACCESS_KEY_ID': "dummykey",
        'AWS_SECRET_ACCESS_KEY': "dummysecret"
    }

    # backend_a = [
    #     Instance(BRIG, 8282),
    #     Instance(GALLEY, 8285),
    #     Instance(GUNDECK, 8286),
    #     Instance(CANNON, 8283),
    #     Instance(CANNON, 8383),
    #     Instance(CARGOHOLD, 8284),
    #     Instance(SPAR, 8288),
    #     FederatorInstance(8297, 8298),
    #     NginzInstance(8080)
    # ]

    backend_a = [
        Instance(BRIG, 8082),
        Instance(GALLEY, 8085),
        Instance(GUNDECK, 8086),
        Instance(CANNON, 8083),
        Instance(CANNON, 8183),
        Instance(CARGOHOLD, 8084),
        Instance(SPAR, 8088),
        FederatorInstance(8097, 8098),
        NginzInstance(
            local_port=8080,
            http2_port=8090,
            ssl_port=8443)
    ]

    check_prerequisites(set(s.service for s in backend_a))

    try:
        instances = set()
        instances |= start_backend(backend_a)
        # instances |= start_backend(backend_b)

        # main script
        ret = subprocess.run(sys.argv[1:])
        sys.exit(ret.returncode)
    except KeyboardInterrupt:
        pass
    finally:
        for instance in instances:
            instance.process.terminate()

        for instance in instances:
            instance.thread.join(timeout=0.1)
            # some services don't react promptly to SIGTERM, so we give them a
            # nudge if they don't terminate within a few milliseconds
            if instance.thread.is_alive():
                instance.process.terminate()
                instance.thread.join(timeout=0.1)
            if instance.thread.is_alive():
                print("force-killing", instance.service.name)
                instance.process.send_signal(signal.SIGKILl)
                instance.thread.join()
