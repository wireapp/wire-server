#!/usr/bin/env python3

from dataclasses import dataclass
import os
import select
import signal
import shutil
import socket
import subprocess
import yaml
import urllib.request
import urllib.error
import sys
import time
import threading
import logging

class Colors:
    GREEN = "\x1b[38;5;10m"
    YELLOW = "\x1b[38;5;11m"
    BLUE = "\x1b[38;5;6m"
    PURPLEISH = "\x1b[38;5;13m"
    ORANGE = "\x1b[38;5;3m"
    RED = "\x1b[38;5;1m"
    RESET = "\x1b[0m"

@dataclass(frozen=True)
class Service:
    name: str
    color: str
    _internal_name: str = None
    check_status: bool = True

    @property
    def internal_name(self):
        if self._internal_name is None:
            return self.name
        else:
            return self._internal_name
    
    def path(self):
        return os.path.join(ROOT, "dist", self.name)

    def config_file(self):
        return os.path.join(ROOT, "services", self.name,
                            self.name + ".integration.yaml")

    def modified_config_file(self, service_map):
        """Overwrite port configuration on this service using the provided
        service_map.

        This works by creating an unnamed pipe, writing the modified config
        file to it, and returning a path to the read end of the pipe (in
        /proc)."""
        (r, w) = os.pipe()

        with open(self.config_file()) as f:
            data = yaml.safe_load(f)

        for service, port in service_map.items():
            if service.internal_name in data:
                data[service.internal_name]['port'] = port

        out = os.fdopen(w, 'w')
        yaml.dump(data, out)

        return f"/proc/{os.getpid()}/fd/{r}"

    def spawn(self, service_map, environment):
        config_file = self.modified_config_file(service_map)
        return subprocess.Popen([self.path(), "-c", config_file],
                               encoding='utf-8',
                               cwd=os.path.join(ROOT, "services", self.name),
                               env=environment,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT)

    def check_exists(self):
        if not os.path.exists(self.path()):
            raise Exception(f"{self.name} not found")

@dataclass(frozen=True)
class Nginz:
    color: str

    @property
    def name(self): return "nginz"

    @property
    def internal_name(self): return self.name

    @property
    def check_status(self): return True

    def spawn(self, service_map, environment):
        cwd = os.path.join(ROOT, "services", "nginz", "integration-test")
        return subprocess.Popen([shutil.which("nginx"), "-p", cwd, "-c",
                                os.path.join(cwd, "conf", "nginz","nginx.conf"),
                                "-g", "daemon off;"],
                                encoding='utf-8', cwd=cwd, env=environment,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)

    def check_exists(self):
        if shutil.which("nginx") is None:
            raise Exception("nginx not found")

def check_prerequisites(service_map):
    try:
        for port in (9042, 9200, 6379):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect(("127.0.0.1", port))
    except Exception as e:
        logging.error(f"{Colors.RED}Databases not up. Try running 'deploy/dockerephemeral/run.sh'. {Colors.RESET}")
        sys.exit(1)

    try:
        for service in service_map:
            service.check_exists()
    except Exception as e:
        logging.error(Colors.RED + str(e) + Colors.RESET)
        sys.exit(1)

def check_status(sub, port, service):
    sub.poll()
    if sub.returncode is not None:
        raise Exception(f"{service.name} has terminated")
    if not service.check_status:
        return True
    try:
        with urllib.request.urlopen(f"http://localhost:{port}/i/status") as resp:
            return resp.status in [200, 204]
    except urllib.error.URLError:
        return False

def color_output(sub, service):
    try:
        for line in sub.stdout:
            logging.info(f"{service.color}[{service.name}] {line.rstrip()}{Colors.RESET}")
    finally:
        sub.terminate()
        sub.wait()


def find_root(base):
    # find git repository
    root = os.path.realpath(base)
    while not os.path.exists(os.path.join(root, ".git")):
        p = os.path.dirname(root)
        if p == root: raise Exception("Could not find wire-server root")
        root = p
    return root

if __name__ == '__main__':
    logging.basicConfig(encoding='utf-8', level=logging.INFO,
                        format='%(message)s')
    ROOT = find_root(os.getcwd())
    if ROOT is None:
        error("This script needs to be run within the wire-server direnv")

    environment = {
        'AWS_REGION': "eu-west-1",
        'AWS_ACCESS_KEY_ID': "dummykey",
        'AWS_SECRET_ACCESS_KEY': "dummysecret"
    }

    brig = Service("brig", Colors.GREEN)
    galley = Service("galley", Colors.YELLOW)
    gundeck = Service("gundeck", Colors.BLUE)
    cannon = Service("cannon", Colors.ORANGE)
    cargohold = Service("cargohold", Colors.PURPLEISH)
    spar = Service("spar", Colors.ORANGE)
    federator = Service("federator", Colors.BLUE,
                        "federatorInternal", check_status=False)
    stern = Service("stern", Colors.YELLOW)
    nginz = Nginz(Colors.PURPLEISH)

    service_map = {
        brig: 8082,
        galley: 8085,
        gundeck: 8086,
        cannon: 8083,
        cargohold: 8084,
        spar: 8088,
        federator: 8097,
        nginz: 8080
    }

    check_prerequisites(service_map)

    try:
        threads = {}
        for service in service_map.keys():
            sub = service.spawn(service_map, environment)
            t = threading.Thread(target=lambda: color_output(sub, service))
            t.start()
            threads[service] = {
                    'thread': t,
                    'process': sub
            }

        # check status
        services = set(threads)
        while services:
            service = next(iter(services))
            if check_status(threads[service]['process'],
                            service_map[service],
                            service):
                services.remove(service)

        # main script
        subprocess.run(sys.argv[1:], check=True)

        for service in threads: threads[service]['process'].terminate()
        for service in threads: threads[service]['thread'].join()
    except KeyboardInterrupt:
        pass
