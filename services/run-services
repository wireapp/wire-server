#!/usr/bin/env python3

from dataclasses import dataclass, replace
import os
import re
import select
import signal
import shutil
import socket
import subprocess
import yaml
import urllib.request
import urllib.error
import sys
import tempfile
import time
import threading
import logging

@dataclass
class SpawnFailException(Exception):
    failed_instances: object

class Colors:
    GREEN = "\x1b[38;5;10m"
    YELLOW = "\x1b[38;5;11m"
    BLUE = "\x1b[38;5;6m"
    PURPLEISH = "\x1b[38;5;13m"
    ORANGE = "\x1b[38;5;3m"
    RED = "\x1b[38;5;1m"
    RESET = "\x1b[0m"

@dataclass(frozen=True)
class Service:
    name: str
    color: str
    _internal_name: str = None
    check_status: bool = True

    @property
    def internal_name(self):
        if self._internal_name is None:
            return self.name
        else:
            return self._internal_name
    
    def path(self):
        return os.path.join(ROOT, "dist", self.name)

    def config_file(self):
        return os.path.join(ROOT, "services", self.name,
                            self.name + ".integration.yaml")


    def spawn(self, config_file, environment):
        return subprocess.Popen([self.path(), "-c", config_file],
                               encoding='utf-8',
                               cwd=os.path.join(ROOT, "services", self.name),
                               env=environment,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT)

    def check_exists(self):
        if not os.path.exists(self.path()):
            raise Exception(f"{self.name} not found")

@dataclass(frozen=True)
class Nginz:
    color: str

    @property
    def name(self): return "nginz"

    @property
    def internal_name(self): return self.name

    @property
    def check_status(self): return True

    def config_file(self):
        return os.path.join(ROOT, "services", "nginz", "integration-test",
                            "conf", "nginz","nginx.conf")

    def spawn(self, config_file, environment):
        cwd = os.path.join(ROOT, "services", "nginz", "integration-test")
        return subprocess.Popen([shutil.which("nginx"), "-p", cwd, "-c",
                                config_file,
                                "-g", "daemon off;"],
                                encoding='utf-8', cwd=cwd, env=environment,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)

    def check_exists(self):
        if shutil.which("nginx") is None:
            raise Exception("nginx not found")

@dataclass(frozen=True)
class Instance:
    service: Service
    port: int
    thread: threading.Thread = None
    process: subprocess.Popen = None
    exception: Exception = None

    def check_status(self):
        self.process.poll()
        if self.process.returncode is not None:
            raise Exception(f"{self.service.name} has terminated")
        if not self.service.check_status:
            return True
        try:
            with urllib.request.urlopen(f"http://localhost:{self.port}/i/status") as resp:
                return resp.status in [200, 204]
        except urllib.error.URLError:
            return False

    def spawn(self, service_map, environment, keyspace, domain):
        try:
            config_file = self.modified_config_file(service_map, keyspace, domain)
            sub = self.service.spawn(config_file, environment)
            t = threading.Thread(target=lambda: color_output(sub, self.service))
            t.start()
            return Instance(self.service, self.port, t, sub)
        except Exception as e:
            return Instance(self.service, self.port, exception=e)

    def modified_config_file(self, service_map, keyspace, domain):
        """Overwrite port configuration on this service using the provided
        service_map.

        This works by creating an unnamed pipe, writing the modified config
        file to it, and returning a path to the read end of the pipe (in
        /proc)."""

        def get_port(service):
            if service is self.service:
                return self.port
            else:
                return service_map[service]

        with open(self.service.config_file()) as f:
            data = yaml.safe_load(f)

        # set ports of other services
        for service in service_map:
            if service.internal_name in data:
                data[service.internal_name]['port'] = get_port(service)

        # set cassandra keyspace
        if 'cassandra' in data:
            data['cassandra']['keyspace'] = f"{self.service.name}_{keyspace}"

        # set federation domain
        if 'optSettings' in data:
            data['optSettings']['setFederationDomain'] = domain
        elif 'settings' in data:
            data['settings']['federationDomain'] = domain

        self.set_own_port(data)

        # write modified config file to pipe
        return make_pipe(yaml.dump(data).encode('utf-8'))

    def set_own_port(self, data):
        # spar's own port is in a different place
        if 'saml' in data:
            data['saml']['spPort'] = self.port

class FederatorInstance(Instance):
    def __init__(self, internal_port, external_port):
        self.external_port = external_port
        super().__init__(FEDERATOR, internal_port)

    def set_own_port(self, data):
        # set external port only, as the internal one is part of the service
        # map and is set by the general config logic
        data['federatorExternal']['port'] = self.external_port

class NginzInstance(Instance):
    def __init__(self, local_port, http2_port, ssl_port):
        self.http2_port = http2_port
        self.ssl_port = ssl_port
        super().__init__(NGINZ, local_port)

    def modified_config_file(self, service_map, keyspace, domain):
        # Create a whole temporary directory and copy all nginx's config files.
        # This is necessary because nginx assumes local imports are relative to
        # the location of the main configuration file.
        self.tmpdir = tempfile.TemporaryDirectory()
        shutil.copytree(os.path.dirname(self.service.config_file()),
                        self.tmpdir.name,
                        dirs_exist_ok=True)

        # override port configuration
        with open(os.path.join(self.tmpdir.name, "integration.conf"), 'w') as f:
            override = f"""
                listen {self.port};
                listen {self.http2_port} http2;
                listen {self.ssl_port} ssl http2;
                listen [::]:{self.ssl_port} ssl http2;"""
            print(override, file=f)

        # override pid configuration
        with open(os.path.join(self.tmpdir.name, "pid.conf"), 'w') as f:
            pid = os.path.join(self.tmpdir.name, "nginz.pid")
            print(f"pid {pid};", file=f)

        return os.path.join(self.tmpdir.name, "nginx.conf")

def check_prerequisites(services):
    try:
        for port in (9042, 9200, 6379):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect(("127.0.0.1", port))
    except Exception as e:
        logging.error(f"{Colors.RED}Databases not up. Try running 'deploy/dockerephemeral/run.sh'. {Colors.RESET}")
        sys.exit(1)

    try:
        for service in services:
            service.check_exists()
    except Exception as e:
        logging.error(Colors.RED + str(e) + Colors.RESET)
        sys.exit(1)

def color_output(sub, service):
    # TODO: add backend name to the output
    try:
        for line in sub.stdout:
            logging.info(f"{service.color}[{service.name}] {line.rstrip()}{Colors.RESET}")
    finally:
        sub.terminate()
        sub.wait()

def find_root(base):
    # find git repository
    root = os.path.realpath(base)
    while not os.path.exists(os.path.join(root, ".git")):
        p = os.path.dirname(root)
        if p == root: raise Exception("Could not find wire-server root")
        root = p
    return root

def make_pipe(data):
    (r, w) = os.pipe()
    os.write(w, data)
    os.close(w)
    return f"/proc/{os.getpid()}/fd/{r}"

def cleanup_instances(instances):
    for instance in instances:
        if instance.process is None: continue
        instance.process.terminate()

    for instance in instances:
        if instance.thread is None: continue
        instance.thread.join(timeout=0.1)
        # some services don't react promptly to SIGTERM, so we give them a
        # nudge if they don't terminate within a few milliseconds
        if instance.thread.is_alive():
            instance.process.terminate()
            instance.thread.join(timeout=0.1)
        if instance.thread.is_alive():
            print("force-killing", instance.service.name)
            instance.process.send_signal(signal.SIGKILl)
            instance.thread.join()

def start_backend(services, keyspace, domain):
    # build a service map by choosing an arbitrary instance of each service
    service_map = dict((s.service, s.port) for s in services)

    instances = set()
    for blueprint in services:
        instances.add(blueprint.spawn(service_map, environment, keyspace, domain))

    failed_instances = [instance for instance in instances
                        if instance.exception is not None]
    to_be_checked = set(instance for instance in instances
                        if instance.exception is None)

    # check status
    # TODO: global timeout
    while to_be_checked:
        instance = next(iter(to_be_checked))
        try:
            done = instance.check_status()
        except Exception as e:
            failed_instances.append(replace(instance, exception=e))
            done = True

        if done:
            to_be_checked.remove(instance)
        else:
            time.sleep(0.1)

    if failed_instances:

        cleanup_instances(instances)
        raise SpawnFailException(failed_instances)

    return instances

BRIG = Service("brig", Colors.GREEN)
GALLEY = Service("galley", Colors.YELLOW)
GUNDECK = Service("gundeck", Colors.BLUE)
CANNON = Service("cannon", Colors.ORANGE)
CARGOHOLD = Service("cargohold", Colors.PURPLEISH)
SPAR = Service("spar", Colors.ORANGE)
FEDERATOR = Service("federator", Colors.BLUE,
                    "federatorInternal", check_status=False)
STERN = Service("stern", Colors.YELLOW)
NGINZ = Nginz(Colors.PURPLEISH)

if __name__ == '__main__':
    logging.basicConfig(encoding='utf-8', level=logging.INFO,
                        format='%(message)s')
    ROOT = find_root(os.getcwd())
    if ROOT is None:
        error("This script needs to be run within the wire-server direnv")

    environment = {
        'AWS_REGION': "eu-west-1",
        'AWS_ACCESS_KEY_ID': "dummykey",
        'AWS_SECRET_ACCESS_KEY': "dummysecret"
    }

    backend_a = [
        Instance(BRIG, 8082),
        Instance(GALLEY, 8085),
        Instance(GUNDECK, 8086),
        Instance(CANNON, 8083),
        Instance(CANNON, 8183),
        Instance(CARGOHOLD, 8084),
        Instance(SPAR, 8088),
        FederatorInstance(8097, 8098),
        NginzInstance(
            local_port=8080,
            http2_port=8090,
            ssl_port=8443)
    ]

    backend_b = [
        Instance(BRIG, 9082),
        Instance(GALLEY, 9085),
        Instance(GUNDECK, 9086),
        Instance(CANNON, 9083),
        Instance(CANNON, 9183),
        Instance(CARGOHOLD, 9084),
        Instance(SPAR, 9088),
        FederatorInstance(9097, 9098),
        NginzInstance(
            local_port=9080,
            http2_port=9090,
            ssl_port=9443)
    ]

    check_prerequisites(set(s.service for s in backend_a))

    try:
        instances = set()
        instances |= start_backend(backend_a, "test", "example.com")
        instances |= start_backend(backend_b, "test2", "b.example.com")

        # main script
        ret = subprocess.run(sys.argv[1:])
        sys.exit(ret.returncode)
    except KeyboardInterrupt:
        pass
    except SpawnFailException as e:
        print(f"{Colors.RED}The following services failed to start:{Colors.RESET}")
        for instance in e.failed_instances:
            print(f"{instance.service.name} at port {instance.port} ({instance.exception})")
    finally:
        cleanup_instances(instances)
