#!/usr/bin/env python3

from dataclasses import dataclass
import os
import select
import signal
import subprocess
import yaml
import urllib.request
import urllib.error
import sys
from threading import Thread

class Colors:
    GREEN = "\x1b[38;5;10m"
    YELLOW = "\x1b[38;5;11m"
    BLUE = "\x1b[38;5;6m"
    PURPLEISH = "\x1b[38;5;13m"
    ORANGE = "\x1b[38;5;3m"
    RESET = "\x1b[0m"

@dataclass(frozen=True)
class Service:
    name: str
    color: str
    _internal_name: str = None
    check_status: bool = True

    @property
    def internal_name(self):
        if self._internal_name is None:
            return self.name
        else:
            return self._internal_name
    
    def path(self):
        return os.path.join(ROOT, "dist", self.name)

    def config_file(self):
        return os.path.join(ROOT, "services", self.name,
                            self.name + ".integration.yaml")

    def modified_config_file(self, service_map):
        (r, w) = os.pipe()

        with open(self.config_file()) as f:
            data = yaml.safe_load(f)

        for service, port in service_map.items():
            if service.internal_name in data:
                data[service.internal_name]['port'] = port

        out = os.fdopen(w, 'w')
        yaml.dump(data, out)

        return f"/proc/{os.getpid()}/fd/{r}"

def check_prerequisites():
    pass

def spawn(service, service_map, environment):
    config_file = service.modified_config_file(service_map)
    sub = subprocess.Popen([service.path(), "-c", config_file],
                           encoding='utf-8',
                           cwd=os.path.join(ROOT, "services", service.name),
                           env=environment, stdout=subprocess.PIPE)

    port = service_map[service]
    if service.check_status:
        while True:
            sub.poll()
            if sub.returncode is not None:
                raise Exception(f"{service.name} has terminated")
            try:
                with urllib.request.urlopen(f"http://localhost:{port}/i/status") as resp:
                    if resp.status in [200, 204]: break
            except urllib.error.URLError:
                pass

    def colour_output():
        try:
            for line in sub.stdout:
                print(service.color, end='')
                print(f"[{service.name}] ", end='')
                print(line, end='')
                print(Colors.RESET, end='')
        finally:
            sub.terminate()
            sub.wait()

    t = Thread(target=colour_output)
    t.start()
    return t

def find_root(base):
    # find git repository
    root = os.path.realpath(base)
    while not os.path.exists(os.path.join(root, ".git")):
        p = os.path.dirname(root)
        if p == root: raise Exception("Could not find wire-server root")
        root = p
    return root

if __name__ == '__main__':
    ROOT = find_root(os.getcwd())
    if ROOT is None:
        error("This script needs to be run within the wire-server direnv")

    environment = {
        'AWS_REGION': "eu-west-1",
        'AWS_ACCESS_KEY_ID': "dummykey",
        'AWS_SECRET_ACCESS_KEY': "dummysecret"
    }

    brig = Service("brig", Colors.GREEN)
    galley = Service("galley", Colors.YELLOW)
    gundeck = Service("gundeck", Colors.BLUE)
    cannon = Service("cannon", Colors.ORANGE)
    cargohold = Service("cargohold", Colors.PURPLEISH)
    spar = Service("spar", Colors.ORANGE)
    federator = Service("federator", Colors.BLUE,
                        "federatorInternal", check_status=False)
    stern = Service("stern", Colors.YELLOW)

    service_map = {
        brig: 8082,
        galley: 8085,
        gundeck: 8086,
        cannon: 8083,
        cargohold: 8084,
        spar: 8088,
        federator: 8097
    }

    try:
        # TODO: start services in parallel
        for service in service_map.keys():
            spawn(service, service_map, environment)


            # procs[proc.stdout] = {
            #     'process': proc,
            #     'service': service 
            # }

        # while True:
            # (ready, _, _) = select.select([proc['process'].stdout
            #                                for proc in procs.values()], [], [])
            # for f in ready:
            #     data = f.read().decode('utf-8')
            #     col = procs[f]['service'].color
            #     print(col, end='')
            #     print(data, end='')
            #     print(Colors.RESET, end='')
            #     sys.stdout.flush()
    except KeyboardInterrupt:
        pass
    # finally:
    #     for proc in procs.values():
    #         proc['process'].terminate()
    #         proc['process'].wait()
