{-# LANGUAGE RecordWildCards #-}

-- This file is part of the Wire Server implementation.
--
-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>
--
-- This program is free software: you can redistribute it and/or modify it under
-- the terms of the GNU Affero General Public License as published by the Free
-- Software Foundation, either version 3 of the License, or (at your option) any
-- later version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
-- details.
--
-- You should have received a copy of the GNU Affero General Public License along
-- with this program. If not, see <https://www.gnu.org/licenses/>.

module Schema where

import Cassandra
import Data.Conduit
import Data.IP (IP)
import Data.Id
import Data.Time
import Data.UUID
import Galley.Data.Instances ()
import Imports
import Types
import Wire.API.Team.Permission

-- This file was autogenerated by gen-table-types

-- brig.activation_keys

type RowBrigActivationKeys = (Maybe Text, Maybe Text, Maybe Text, Maybe Text, Maybe Text, Maybe Int32, Maybe UUID)

selectBrigActivationKeys :: PrepQuery R (Identity ([UserId])) RowBrigActivationKeys
selectBrigActivationKeys = "SELECT key, challenge, code, key_text, key_type, retries, user FROM activation_keys WHERE user in ?"

readBrigActivationKeys :: Env -> [UserId] -> IO [RowBrigActivationKeys]
readBrigActivationKeys Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigActivationKeys (params Quorum (pure uids)))

readBrigActivationKeysConduit :: Env -> [UserId] -> ConduitM () [RowBrigActivationKeys] IO ()
readBrigActivationKeysConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigActivationKeys (paramsP Quorum (pure uids) envPageSize) x5

insertBrigActivationKeys :: Env -> FilePath -> IO ()
insertBrigActivationKeys _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigActivationKeys';
  -- run Client action on each.
  pure ()

-- brig.clients

type RowBrigClients = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text, Maybe IP, Maybe Text, Maybe Double, Maybe Double, Maybe Text, Maybe UTCTime, Maybe Int32)

selectBrigClients :: PrepQuery R (Identity ([UserId])) RowBrigClients
selectBrigClients = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients WHERE user in ?"

readBrigClients :: Env -> [UserId] -> IO [RowBrigClients]
readBrigClients Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigClients (params Quorum (pure uids)))

readBrigClientsConduit :: Env -> [UserId] -> ConduitM () [RowBrigClients] IO ()
readBrigClientsConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigClients (paramsP Quorum (pure uids) envPageSize) x5

insertBrigClients :: Env -> FilePath -> IO ()
insertBrigClients _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigClients';
  -- run Client action on each.
  pure ()

-- brig.codes

type RowBrigCodes = (Maybe UUID, Maybe Int32, Maybe Text, Maybe Int32)

selectBrigCodes :: PrepQuery R (Identity ([UserId])) RowBrigCodes
selectBrigCodes = "SELECT user, scope, code, retries FROM codes WHERE user in ?"

readBrigCodes :: Env -> [UserId] -> IO [RowBrigCodes]
readBrigCodes Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigCodes (params Quorum (pure uids)))

readBrigCodesConduit :: Env -> [UserId] -> ConduitM () [RowBrigCodes] IO ()
readBrigCodesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigCodes (paramsP Quorum (pure uids) envPageSize) x5

insertBrigCodes :: Env -> FilePath -> IO ()
insertBrigCodes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigCodes';
  -- run Client action on each.
  pure ()

-- brig.connection

type RowBrigConnection = (Maybe UUID, Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe Text, Maybe Int32)

selectBrigConnection :: PrepQuery R (([UserId], [UserId])) RowBrigConnection
selectBrigConnection = "SELECT left, right, conv, last_update, message, status FROM connection WHERE left in ? OR right in ?"

readBrigConnection :: Env -> [UserId] -> IO [RowBrigConnection]
readBrigConnection Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigConnection (params Quorum ((uids, uids))))

readBrigConnectionConduit :: Env -> [UserId] -> ConduitM () [RowBrigConnection] IO ()
readBrigConnectionConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigConnection (paramsP Quorum (pure uids) envPageSize) x5

insertBrigConnection :: Env -> FilePath -> IO ()
insertBrigConnection _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigConnection';
  -- run Client action on each.
  pure ()

-- brig.id_mapping

type RowBrigIdMapping = (Maybe UUID, Maybe Text, Maybe UUID)

selectBrigIdMapping :: PrepQuery R (Identity [UserId]) RowBrigIdMapping
selectBrigIdMapping = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping WHERE mapped_id in ?"

readBrigIdMapping :: Env -> [UserId] -> IO [RowBrigIdMapping]
readBrigIdMapping Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigIdMapping (params Quorum (pure uids)))

readBrigIdMappingConduit :: Env -> [UserId] -> ConduitM () [RowBrigIdMapping] IO ()
readBrigIdMappingConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigIdMapping (paramsP Quorum (pure uids) envPageSize) x5

insertBrigIdMapping :: Env -> FilePath -> IO ()
insertBrigIdMapping _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigIdMapping';
  -- run Client action on each.
  pure ()

-- brig.invitation

type RowBrigInvitation = (Maybe UUID, Maybe UUID, Maybe Text, Maybe UTCTime, Maybe Text, Maybe Text, Maybe Text)

selectBrigInvitation :: PrepQuery R (Identity [UserId]) RowBrigInvitation
selectBrigInvitation = "SELECT inviter, id, code, created_at, email, name, phone FROM invitation WHERE inviter in ?"

readBrigInvitation :: Env -> [UserId] -> IO [RowBrigInvitation]
readBrigInvitation Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigInvitation (params Quorum (pure uids)))

readBrigInvitationConduit :: Env -> [UserId] -> ConduitM () [RowBrigInvitation] IO ()
readBrigInvitationConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigInvitation (paramsP Quorum (pure uids) envPageSize) x5

insertBrigInvitation :: Env -> FilePath -> IO ()
insertBrigInvitation _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigInvitation';
  -- run Client action on each.
  pure ()

-- brig.invitation_info

type RowBrigInvitationInfo = (Maybe Text, Maybe UUID, Maybe UUID)

selectBrigInvitationInfo :: PrepQuery R (Identity [UserId]) RowBrigInvitationInfo
selectBrigInvitationInfo = "SELECT code, id, inviter FROM invitation_info WHERE inviter in ?"

readBrigInvitationInfo :: Env -> [UserId] -> IO [RowBrigInvitationInfo]
readBrigInvitationInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigInvitationInfo (params Quorum (pure uids)))

readBrigInvitationInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigInvitationInfo] IO ()
readBrigInvitationInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigInvitationInfo (paramsP Quorum (pure uids) envPageSize) x5

insertBrigInvitationInfo :: Env -> FilePath -> IO ()
insertBrigInvitationInfo _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigInvitationInfo';
  -- run Client action on each.
  pure ()

-- brig.invitee_info

type RowBrigInviteeInfo = (Maybe UUID, Maybe UUID, Maybe UUID)

selectBrigInviteeInfo :: PrepQuery R (([UserId], [UserId])) RowBrigInviteeInfo
selectBrigInviteeInfo = "SELECT invitee, conv, inviter FROM invitee_info WHERE invitee in ? OR inviter in ?"

readBrigInviteeInfo :: Env -> [UserId] -> IO [RowBrigInviteeInfo]
readBrigInviteeInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigInviteeInfo (params Quorum ((uids, uids))))

readBrigInviteeInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigInviteeInfo] IO ()
readBrigInviteeInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigInviteeInfo (paramsP Quorum (pure uids) envPageSize) x5

insertBrigInviteeInfo :: Env -> FilePath -> IO ()
insertBrigInviteeInfo _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigInviteeInfo';
  -- run Client action on each.
  pure ()

-- brig.login_codes

type RowBrigLoginCodes = (Maybe UUID, Maybe Text, Maybe Int32, Maybe UTCTime)

selectBrigLoginCodes :: PrepQuery R (Identity ([UserId])) RowBrigLoginCodes
selectBrigLoginCodes = "SELECT user, code, retries, timeout FROM login_codes WHERE user in ?"

readBrigLoginCodes :: Env -> [UserId] -> IO [RowBrigLoginCodes]
readBrigLoginCodes Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigLoginCodes (params Quorum (pure uids)))

readBrigLoginCodesConduit :: Env -> [UserId] -> ConduitM () [RowBrigLoginCodes] IO ()
readBrigLoginCodesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigLoginCodes (paramsP Quorum (pure uids) envPageSize) x5

insertBrigLoginCodes :: Env -> FilePath -> IO ()
insertBrigLoginCodes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigLoginCodes';
  -- run Client action on each.
  pure ()

-- brig.password_reset

type RowBrigPasswordReset = (Maybe Text, Maybe Text, Maybe Int32, Maybe UTCTime, Maybe UUID)

selectBrigPasswordReset :: PrepQuery R (Identity ([UserId])) RowBrigPasswordReset
selectBrigPasswordReset = "SELECT key, code, retries, timeout, user FROM password_reset WHERE user in ?"

readBrigPasswordReset :: Env -> [UserId] -> IO [RowBrigPasswordReset]
readBrigPasswordReset Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigPasswordReset (params Quorum (pure uids)))

readBrigPasswordResetConduit :: Env -> [UserId] -> ConduitM () [RowBrigPasswordReset] IO ()
readBrigPasswordResetConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigPasswordReset (paramsP Quorum (pure uids) envPageSize) x5

insertBrigPasswordReset :: Env -> FilePath -> IO ()
insertBrigPasswordReset _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigPasswordReset';
  -- run Client action on each.
  pure ()

-- brig.prekeys

type RowBrigPrekeys = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text)

selectBrigPrekeys :: PrepQuery R (Identity ([UserId])) RowBrigPrekeys
selectBrigPrekeys = "SELECT user, client, key, data FROM prekeys WHERE user in ?"

readBrigPrekeys :: Env -> [UserId] -> IO [RowBrigPrekeys]
readBrigPrekeys Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigPrekeys (params Quorum (pure uids)))

readBrigPrekeysConduit :: Env -> [UserId] -> ConduitM () [RowBrigPrekeys] IO ()
readBrigPrekeysConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigPrekeys (paramsP Quorum (pure uids) envPageSize) x5

insertBrigPrekeys :: Env -> FilePath -> IO ()
insertBrigPrekeys _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigPrekeys';
  -- run Client action on each.
  pure ()

-- brig.properties

type RowBrigProperties = (Maybe UUID, Maybe Text, Maybe Blob)

selectBrigProperties :: PrepQuery R (Identity ([UserId])) RowBrigProperties
selectBrigProperties = "SELECT user, key, value FROM properties WHERE user in ?"

readBrigProperties :: Env -> [UserId] -> IO [RowBrigProperties]
readBrigProperties Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigProperties (params Quorum (pure uids)))

readBrigPropertiesConduit :: Env -> [UserId] -> ConduitM () [RowBrigProperties] IO ()
readBrigPropertiesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigProperties (paramsP Quorum (pure uids) envPageSize) x5

insertBrigProperties :: Env -> FilePath -> IO ()
insertBrigProperties _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigProperties';
  -- run Client action on each.
  pure ()

-- brig.rich_info

type RowBrigRichInfo = (Maybe UUID, Maybe Blob)

selectBrigRichInfo :: PrepQuery R (Identity ([UserId])) RowBrigRichInfo
selectBrigRichInfo = "SELECT user, json FROM rich_info WHERE user in ?"

readBrigRichInfo :: Env -> [UserId] -> IO [RowBrigRichInfo]
readBrigRichInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigRichInfo (params Quorum (pure uids)))

readBrigRichInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigRichInfo] IO ()
readBrigRichInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigRichInfo (paramsP Quorum (pure uids) envPageSize) x5

insertBrigRichInfo :: Env -> FilePath -> IO ()
insertBrigRichInfo _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigRichInfo';
  -- run Client action on each.
  pure ()

-- brig.team_invitation

type RowBrigTeamInvitation = (Maybe UUID, Maybe UUID, Maybe Text, Maybe UTCTime, Maybe UUID, Maybe Text, Maybe Text, Maybe Text, Maybe Int32)

selectBrigTeamInvitation :: PrepQuery R (Identity TeamId) RowBrigTeamInvitation
selectBrigTeamInvitation = "SELECT team, id, code, created_at, created_by, email, name, phone, role FROM team_invitation WHERE team = ?"

readBrigTeamInvitation :: Env -> TeamId -> IO [RowBrigTeamInvitation]
readBrigTeamInvitation Env {..} tid =
  runClient envBrig $
    retry x1 (query selectBrigTeamInvitation (params Quorum (pure tid)))

readBrigTeamInvitationConduit :: Env -> TeamId -> ConduitM () [RowBrigTeamInvitation] IO ()
readBrigTeamInvitationConduit Env {..} tid =
  transPipe (runClient envBrig) $
    paginateC selectBrigTeamInvitation (paramsP Quorum (pure tid) envPageSize) x5

insertBrigTeamInvitation :: Env -> FilePath -> IO ()
insertBrigTeamInvitation _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigTeamInvitation';
  -- run Client action on each.
  pure ()

-- brig.team_invitation_email

type RowBrigTeamInvitationEmail = (Maybe Text, Maybe UUID, Maybe Text, Maybe UUID)

selectBrigTeamInvitationEmail :: PrepQuery R (Identity TeamId) RowBrigTeamInvitationEmail
selectBrigTeamInvitationEmail = "SELECT email, team, code, invitation FROM team_invitation_email WHERE team = ?"

readBrigTeamInvitationEmail :: Env -> TeamId -> IO [RowBrigTeamInvitationEmail]
readBrigTeamInvitationEmail Env {..} tid =
  runClient envBrig $
    retry x1 (query selectBrigTeamInvitationEmail (params Quorum (pure tid)))

readBrigTeamInvitationEmailConduit :: Env -> TeamId -> ConduitM () [RowBrigTeamInvitationEmail] IO ()
readBrigTeamInvitationEmailConduit Env {..} tid =
  transPipe (runClient envBrig) $
    paginateC selectBrigTeamInvitationEmail (paramsP Quorum (pure tid) envPageSize) x5

insertBrigTeamInvitationEmail :: Env -> FilePath -> IO ()
insertBrigTeamInvitationEmail _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigTeamInvitationEmail';
  -- run Client action on each.
  pure ()

-- brig.team_invitation_info

type RowBrigTeamInvitationInfo = (Maybe Text, Maybe UUID, Maybe UUID)

selectBrigTeamInvitationInfo :: PrepQuery R (Identity [UserId]) RowBrigTeamInvitationInfo
selectBrigTeamInvitationInfo = "SELECT code, id, team FROM team_invitation_info WHERE inviter in ?"

readBrigTeamInvitationInfo :: Env -> [UserId] -> IO [RowBrigTeamInvitationInfo]
readBrigTeamInvitationInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigTeamInvitationInfo (params Quorum (pure uids)))

readBrigTeamInvitationInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigTeamInvitationInfo] IO ()
readBrigTeamInvitationInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigTeamInvitationInfo (paramsP Quorum (pure uids) envPageSize) x5

insertBrigTeamInvitationInfo :: Env -> FilePath -> IO ()
insertBrigTeamInvitationInfo _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigTeamInvitationInfo';
  -- run Client action on each.
  pure ()

-- brig.user

type RowBrigUser = (Maybe UUID, Maybe [Double], Maybe Int32, Maybe Bool, Maybe [AssetIgnoreData], Maybe Text, Maybe Text, Maybe UTCTime, Maybe Text, Maybe Text, Maybe Int32, Maybe Text, Maybe Blob, Maybe Text, Maybe [Blob], Maybe UUID, Maybe Bool, Maybe UUID, Maybe Text, Maybe Int32, Maybe UUID)

selectBrigUser :: PrepQuery R (Identity [UserId]) RowBrigUser
selectBrigUser = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user WHERE id in ?"

readBrigUser :: Env -> [UserId] -> IO [RowBrigUser]
readBrigUser Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUser (params Quorum (pure uids)))

readBrigUserConduit :: Env -> [UserId] -> ConduitM () [RowBrigUser] IO ()
readBrigUserConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUser (paramsP Quorum (pure uids) envPageSize) x5

insertBrigUser :: Env -> FilePath -> IO ()
insertBrigUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUser';
  -- run Client action on each.
  pure ()

-- brig.user_cookies

type RowBrigUserCookies = (Maybe UUID, Maybe UTCTime, Maybe Integer, Maybe UTCTime, Maybe Text, Maybe Integer, Maybe Int32)

selectBrigUserCookies :: PrepQuery R (Identity ([UserId])) RowBrigUserCookies
selectBrigUserCookies = "SELECT user, expires, id, created, label, succ_id, type FROM user_cookies WHERE user in ?"

readBrigUserCookies :: Env -> [UserId] -> IO [RowBrigUserCookies]
readBrigUserCookies Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUserCookies (params Quorum (pure uids)))

readBrigUserCookiesConduit :: Env -> [UserId] -> ConduitM () [RowBrigUserCookies] IO ()
readBrigUserCookiesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserCookies (paramsP Quorum (pure uids) envPageSize) x5

insertBrigUserCookies :: Env -> FilePath -> IO ()
insertBrigUserCookies _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUserCookies';
  -- run Client action on each.
  pure ()

-- brig.user_handle

type RowBrigUserHandle = (Maybe Text, Maybe UUID)

selectBrigUserHandle :: PrepQuery R (Identity ([UserId])) RowBrigUserHandle
selectBrigUserHandle = "SELECT handle, user FROM user_handle WHERE user in ?"

readBrigUserHandle :: Env -> [UserId] -> IO [RowBrigUserHandle]
readBrigUserHandle Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUserHandle (params Quorum (pure uids)))

readBrigUserHandleConduit :: Env -> [UserId] -> ConduitM () [RowBrigUserHandle] IO ()
readBrigUserHandleConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserHandle (paramsP Quorum (pure uids) envPageSize) x5

insertBrigUserHandle :: Env -> FilePath -> IO ()
insertBrigUserHandle _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUserHandle';
  -- run Client action on each.
  pure ()

-- brig.user_keys

type RowBrigUserKeys = (Maybe Text, Maybe UUID)

selectBrigUserKeys :: PrepQuery R (Identity ([UserId])) RowBrigUserKeys
selectBrigUserKeys = "SELECT key, user FROM user_keys WHERE user in ?"

readBrigUserKeys :: Env -> [UserId] -> IO [RowBrigUserKeys]
readBrigUserKeys Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUserKeys (params Quorum (pure uids)))

readBrigUserKeysConduit :: Env -> [UserId] -> ConduitM () [RowBrigUserKeys] IO ()
readBrigUserKeysConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserKeys (paramsP Quorum (pure uids) envPageSize) x5

insertBrigUserKeys :: Env -> FilePath -> IO ()
insertBrigUserKeys _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUserKeys';
  -- run Client action on each.
  pure ()

-- brig.user_keys_hash

type RowBrigUserKeysHash = (Maybe Blob, Maybe Int32, Maybe UUID)

selectBrigUserKeysHash :: PrepQuery R (Identity ([UserId])) RowBrigUserKeysHash
selectBrigUserKeysHash = "SELECT key, key_type, user FROM user_keys_hash WHERE user in ?"

readBrigUserKeysHash :: Env -> [UserId] -> IO [RowBrigUserKeysHash]
readBrigUserKeysHash Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUserKeysHash (params Quorum (pure uids)))

readBrigUserKeysHashConduit :: Env -> [UserId] -> ConduitM () [RowBrigUserKeysHash] IO ()
readBrigUserKeysHashConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserKeysHash (paramsP Quorum (pure uids) envPageSize) x5

insertBrigUserKeysHash :: Env -> FilePath -> IO ()
insertBrigUserKeysHash _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUserKeysHash';
  -- run Client action on each.
  pure ()

-- galley.billing_team_member

type RowGalleyBillingTeamMember = (Maybe UUID, Maybe UUID)

selectGalleyBillingTeamMember :: PrepQuery R (Identity TeamId) RowGalleyBillingTeamMember
selectGalleyBillingTeamMember = "SELECT team, user FROM billing_team_member WHERE team = ?"

readGalleyBillingTeamMember :: Env -> TeamId -> IO [RowGalleyBillingTeamMember]
readGalleyBillingTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyBillingTeamMember (params Quorum (pure tid)))

readGalleyBillingTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyBillingTeamMember] IO ()
readGalleyBillingTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyBillingTeamMember (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyBillingTeamMember :: Env -> FilePath -> IO ()
insertGalleyBillingTeamMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyBillingTeamMember';
  -- run Client action on each.
  pure ()

-- galley.clients

type RowGalleyClients = (Maybe UUID, Maybe (Cassandra.Set Text))

selectGalleyClients :: PrepQuery R (Identity ([UserId])) RowGalleyClients
selectGalleyClients = "SELECT user, clients FROM clients WHERE user in ?"

readGalleyClients :: Env -> [UserId] -> IO [RowGalleyClients]
readGalleyClients Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyClients (params Quorum (pure uids)))

readGalleyClientsConduit :: Env -> [UserId] -> ConduitM () [RowGalleyClients] IO ()
readGalleyClientsConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyClients (paramsP Quorum (pure uids) envPageSize) x5

insertGalleyClients :: Env -> FilePath -> IO ()
insertGalleyClients _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyClients';
  -- run Client action on each.
  pure ()

-- galley.conversation

type RowGalleyConversation = (Maybe UUID, Maybe (Cassandra.Set Int32), Maybe Int32, Maybe UUID, Maybe Bool, Maybe Integer, Maybe Text, Maybe Int32, Maybe UUID, Maybe Int32)

selectGalleyConversation :: PrepQuery R (Identity TeamId) RowGalleyConversation
selectGalleyConversation = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation WHERE team = ?"

readGalleyConversation :: Env -> TeamId -> IO [RowGalleyConversation]
readGalleyConversation Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyConversation (params Quorum (pure tid)))

readGalleyConversationConduit :: Env -> TeamId -> ConduitM () [RowGalleyConversation] IO ()
readGalleyConversationConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyConversation (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyConversation :: Env -> FilePath -> IO ()
insertGalleyConversation _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyConversation';
  -- run Client action on each.
  pure ()

-- galley.legalhold_pending_prekeys

type RowGalleyLegalholdPendingPrekeys = (Maybe UUID, Maybe Int32, Maybe Text)

selectGalleyLegalholdPendingPrekeys :: PrepQuery R (Identity ([UserId])) RowGalleyLegalholdPendingPrekeys
selectGalleyLegalholdPendingPrekeys = "SELECT user, key, data FROM legalhold_pending_prekeys WHERE user in ?"

readGalleyLegalholdPendingPrekeys :: Env -> [UserId] -> IO [RowGalleyLegalholdPendingPrekeys]
readGalleyLegalholdPendingPrekeys Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyLegalholdPendingPrekeys (params Quorum (pure uids)))

readGalleyLegalholdPendingPrekeysConduit :: Env -> [UserId] -> ConduitM () [RowGalleyLegalholdPendingPrekeys] IO ()
readGalleyLegalholdPendingPrekeysConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyLegalholdPendingPrekeys (paramsP Quorum (pure uids) envPageSize) x5

insertGalleyLegalholdPendingPrekeys :: Env -> FilePath -> IO ()
insertGalleyLegalholdPendingPrekeys _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyLegalholdPendingPrekeys';
  -- run Client action on each.
  pure ()

-- galley.legalhold_service

type RowGalleyLegalholdService = (Maybe UUID, Maybe Text, Maybe Blob, Maybe Blob, Maybe Blob)

selectGalleyLegalholdService :: PrepQuery R (Identity TeamId) RowGalleyLegalholdService
selectGalleyLegalholdService = "SELECT team_id, auth_token, base_url, fingerprint, pubkey FROM legalhold_service WHERE team = ?"

readGalleyLegalholdService :: Env -> TeamId -> IO [RowGalleyLegalholdService]
readGalleyLegalholdService Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyLegalholdService (params Quorum (pure tid)))

readGalleyLegalholdServiceConduit :: Env -> TeamId -> ConduitM () [RowGalleyLegalholdService] IO ()
readGalleyLegalholdServiceConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyLegalholdService (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyLegalholdService :: Env -> FilePath -> IO ()
insertGalleyLegalholdService _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyLegalholdService';
  -- run Client action on each.
  pure ()

-- galley.member

type RowGalleyMember = (Maybe UUID, Maybe UUID, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Int32, Maybe UUID, Maybe UUID, Maybe Int32, Maybe Text, Maybe UUID)

selectGalleyMember :: PrepQuery R (Identity ([UserId])) RowGalleyMember
selectGalleyMember = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member WHERE user in ?"

readGalleyMember :: Env -> [UserId] -> IO [RowGalleyMember]
readGalleyMember Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyMember (params Quorum (pure uids)))

readGalleyMemberConduit :: Env -> [UserId] -> ConduitM () [RowGalleyMember] IO ()
readGalleyMemberConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyMember (paramsP Quorum (pure uids) envPageSize) x5

insertGalleyMember :: Env -> FilePath -> IO ()
insertGalleyMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyMember';
  -- run Client action on each.
  pure ()

-- galley.team

type RowGalleyTeam = (Maybe UUID, Maybe Bool, Maybe UUID, Maybe Bool, Maybe Text, Maybe Text, Maybe Text, Maybe Int32, Maybe Int32)

selectGalleyTeam :: PrepQuery R (Identity TeamId) RowGalleyTeam
selectGalleyTeam = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team WHERE team = ?"

readGalleyTeam :: Env -> TeamId -> IO [RowGalleyTeam]
readGalleyTeam Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeam (params Quorum (pure tid)))

readGalleyTeamConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeam] IO ()
readGalleyTeamConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeam (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyTeam :: Env -> FilePath -> IO ()
insertGalleyTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeam';
  -- run Client action on each.
  pure ()

-- galley.team_conv

type RowGalleyTeamConv = (Maybe UUID, Maybe UUID, Maybe Bool)

selectGalleyTeamConv :: PrepQuery R (Identity TeamId) RowGalleyTeamConv
selectGalleyTeamConv = "SELECT team, conv, managed FROM team_conv WHERE team = ?"

readGalleyTeamConv :: Env -> TeamId -> IO [RowGalleyTeamConv]
readGalleyTeamConv Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamConv (params Quorum (pure tid)))

readGalleyTeamConvConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamConv] IO ()
readGalleyTeamConvConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamConv (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyTeamConv :: Env -> FilePath -> IO ()
insertGalleyTeamConv _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamConv';
  -- run Client action on each.
  pure ()

-- galley.team_features

type RowGalleyTeamFeatures = (Maybe UUID, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32)

selectGalleyTeamFeatures :: PrepQuery R (Identity TeamId) RowGalleyTeamFeatures
selectGalleyTeamFeatures = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features WHERE team = ?"

readGalleyTeamFeatures :: Env -> TeamId -> IO [RowGalleyTeamFeatures]
readGalleyTeamFeatures Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamFeatures (params Quorum (pure tid)))

readGalleyTeamFeaturesConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamFeatures] IO ()
readGalleyTeamFeaturesConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamFeatures (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyTeamFeatures :: Env -> FilePath -> IO ()
insertGalleyTeamFeatures _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamFeatures';
  -- run Client action on each.
  pure ()

-- galley.team_member

type RowGalleyTeamMember = (Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe UUID, Maybe Int32, Maybe Permissions)

selectGalleyTeamMember :: PrepQuery R (Identity TeamId) RowGalleyTeamMember
selectGalleyTeamMember = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member WHERE team = ?"

readGalleyTeamMember :: Env -> TeamId -> IO [RowGalleyTeamMember]
readGalleyTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamMember (params Quorum (pure tid)))

readGalleyTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamMember] IO ()
readGalleyTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamMember (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyTeamMember :: Env -> FilePath -> IO ()
insertGalleyTeamMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamMember';
  -- run Client action on each.
  pure ()

-- galley.team_notifications

type RowGalleyTeamNotifications = (Maybe UUID, Maybe UUID, Maybe Blob)

selectGalleyTeamNotifications :: PrepQuery R (Identity TeamId) RowGalleyTeamNotifications
selectGalleyTeamNotifications = "SELECT team, id, payload FROM team_notifications WHERE team = ?"

readGalleyTeamNotifications :: Env -> TeamId -> IO [RowGalleyTeamNotifications]
readGalleyTeamNotifications Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamNotifications (params Quorum (pure tid)))

readGalleyTeamNotificationsConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamNotifications] IO ()
readGalleyTeamNotificationsConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamNotifications (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyTeamNotifications :: Env -> FilePath -> IO ()
insertGalleyTeamNotifications _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamNotifications';
  -- run Client action on each.
  pure ()

-- galley.user

type RowGalleyUser = (Maybe UUID, Maybe UUID, Maybe Text, Maybe UUID)

selectGalleyUser :: PrepQuery R (Identity ([UserId])) RowGalleyUser
selectGalleyUser = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user WHERE user in ?"

readGalleyUser :: Env -> [UserId] -> IO [RowGalleyUser]
readGalleyUser Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUser (params Quorum (pure uids)))

readGalleyUserConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUser] IO ()
readGalleyUserConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUser (paramsP Quorum (pure uids) envPageSize) x5

insertGalleyUser :: Env -> FilePath -> IO ()
insertGalleyUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyUser';
  -- run Client action on each.
  pure ()

-- galley.user_team

type RowGalleyUserTeam = (Maybe UUID, Maybe UUID)

selectGalleyUserTeam :: PrepQuery R (Identity TeamId) RowGalleyUserTeam
selectGalleyUserTeam = "SELECT user, team FROM user_team WHERE team = ?"

readGalleyUserTeam :: Env -> TeamId -> IO [RowGalleyUserTeam]
readGalleyUserTeam Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyUserTeam (params Quorum (pure tid)))

readGalleyUserTeamConduit :: Env -> TeamId -> ConduitM () [RowGalleyUserTeam] IO ()
readGalleyUserTeamConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserTeam (paramsP Quorum (pure tid) envPageSize) x5

insertGalleyUserTeam :: Env -> FilePath -> IO ()
insertGalleyUserTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyUserTeam';
  -- run Client action on each.
  pure ()

-- gundeck.notifications

type RowGundeckNotifications = (Maybe UUID, Maybe UUID, Maybe (Cassandra.Set Text), Maybe Blob)

selectGundeckNotifications :: PrepQuery R (Identity ([UserId])) RowGundeckNotifications
selectGundeckNotifications = "SELECT user, id, clients, payload FROM notifications WHERE user in ?"

readGundeckNotifications :: Env -> [UserId] -> IO [RowGundeckNotifications]
readGundeckNotifications Env {..} uids =
  runClient envGundeck $
    retry x1 (query selectGundeckNotifications (params Quorum (pure uids)))

readGundeckNotificationsConduit :: Env -> [UserId] -> ConduitM () [RowGundeckNotifications] IO ()
readGundeckNotificationsConduit Env {..} uids =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckNotifications (paramsP Quorum (pure uids) envPageSize) x5

insertGundeckNotifications :: Env -> FilePath -> IO ()
insertGundeckNotifications _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGundeckNotifications';
  -- run Client action on each.
  pure ()

-- gundeck.push

type RowGundeckPush = (Maybe Text, Maybe Text, Maybe Int32, Maybe Text, Maybe Blob, Maybe UUID)

selectGundeckPush :: PrepQuery R (Identity [UserId]) RowGundeckPush
selectGundeckPush = "SELECT ptoken, app, transport, client, connection, usr FROM push WHERE usr in ?"

readGundeckPush :: Env -> [UserId] -> IO [RowGundeckPush]
readGundeckPush Env {..} uids =
  runClient envGundeck $
    retry x1 (query selectGundeckPush (params Quorum (pure uids)))

readGundeckPushConduit :: Env -> [UserId] -> ConduitM () [RowGundeckPush] IO ()
readGundeckPushConduit Env {..} uids =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckPush (paramsP Quorum (pure uids) envPageSize) x5

insertGundeckPush :: Env -> FilePath -> IO ()
insertGundeckPush _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGundeckPush';
  -- run Client action on each.
  pure ()

-- gundeck.user_push

type RowGundeckUserPush = (Maybe UUID, Maybe Text, Maybe Text, Maybe Int32, Maybe Text, Maybe Text, Maybe Blob)

selectGundeckUserPush :: PrepQuery R (Identity [UserId]) RowGundeckUserPush
selectGundeckUserPush = "SELECT usr, ptoken, app, transport, arn, client, connection FROM user_push WHERE usr in ?"

readGundeckUserPush :: Env -> [UserId] -> IO [RowGundeckUserPush]
readGundeckUserPush Env {..} uids =
  runClient envGundeck $
    retry x1 (query selectGundeckUserPush (params Quorum (pure uids)))

readGundeckUserPushConduit :: Env -> [UserId] -> ConduitM () [RowGundeckUserPush] IO ()
readGundeckUserPushConduit Env {..} uids =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckUserPush (paramsP Quorum (pure uids) envPageSize) x5

insertGundeckUserPush :: Env -> FilePath -> IO ()
insertGundeckUserPush _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGundeckUserPush';
  -- run Client action on each.
  pure ()

-- spar.bind_cookie

type RowSparBindCookie = (Maybe Text, Maybe UUID)

selectSparBindCookie :: PrepQuery R (Identity [UserId]) RowSparBindCookie
selectSparBindCookie = "SELECT cookie, session_owner FROM bind_cookie WHERE session_owner in ?"

readSparBindCookie :: Env -> [UserId] -> IO [RowSparBindCookie]
readSparBindCookie Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparBindCookie (params Quorum (pure uids)))

readSparBindCookieConduit :: Env -> [UserId] -> ConduitM () [RowSparBindCookie] IO ()
readSparBindCookieConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparBindCookie (paramsP Quorum (pure uids) envPageSize) x5

insertSparBindCookie :: Env -> FilePath -> IO ()
insertSparBindCookie _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparBindCookie';
  -- run Client action on each.
  pure ()

-- spar.idp

type RowSparIdp = (Maybe UUID, Maybe [Blob], Maybe Text, Maybe [Text], Maybe Blob, Maybe UUID, Maybe Text, Maybe UUID)

selectSparIdp :: PrepQuery R (Identity TeamId) RowSparIdp
selectSparIdp = "SELECT idp, extra_public_keys, issuer, old_issuers, public_key, replaced_by, request_uri, team FROM idp WHERE team = ?"

readSparIdp :: Env -> TeamId -> IO [RowSparIdp]
readSparIdp Env {..} tid =
  runClient envSpar $
    retry x1 (query selectSparIdp (params Quorum (pure tid)))

readSparIdpConduit :: Env -> TeamId -> ConduitM () [RowSparIdp] IO ()
readSparIdpConduit Env {..} tid =
  transPipe (runClient envSpar) $
    paginateC selectSparIdp (paramsP Quorum (pure tid) envPageSize) x5

insertSparIdp :: Env -> FilePath -> IO ()
insertSparIdp _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparIdp';
  -- run Client action on each.
  pure ()

-- spar.scim_external_ids

type RowSparScimExternalIds = (Maybe Text, Maybe UUID)

selectSparScimExternalIds :: PrepQuery R (Identity ([UserId])) RowSparScimExternalIds
selectSparScimExternalIds = "SELECT external, user FROM scim_external_ids WHERE user in ?"

readSparScimExternalIds :: Env -> [UserId] -> IO [RowSparScimExternalIds]
readSparScimExternalIds Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparScimExternalIds (params Quorum (pure uids)))

readSparScimExternalIdsConduit :: Env -> [UserId] -> ConduitM () [RowSparScimExternalIds] IO ()
readSparScimExternalIdsConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparScimExternalIds (paramsP Quorum (pure uids) envPageSize) x5

insertSparScimExternalIds :: Env -> FilePath -> IO ()
insertSparScimExternalIds _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparScimExternalIds';
  -- run Client action on each.
  pure ()

-- spar.scim_user_times

type RowSparScimUserTimes = (Maybe UUID, Maybe UTCTime, Maybe UTCTime)

selectSparScimUserTimes :: PrepQuery R (Identity [UserId]) RowSparScimUserTimes
selectSparScimUserTimes = "SELECT uid, created_at, last_updated_at FROM scim_user_times WHERE uid in ?"

readSparScimUserTimes :: Env -> [UserId] -> IO [RowSparScimUserTimes]
readSparScimUserTimes Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparScimUserTimes (params Quorum (pure uids)))

readSparScimUserTimesConduit :: Env -> [UserId] -> ConduitM () [RowSparScimUserTimes] IO ()
readSparScimUserTimesConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparScimUserTimes (paramsP Quorum (pure uids) envPageSize) x5

insertSparScimUserTimes :: Env -> FilePath -> IO ()
insertSparScimUserTimes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparScimUserTimes';
  -- run Client action on each.
  pure ()

-- spar.team_idp

type RowSparTeamIdp = (Maybe UUID, Maybe UUID)

selectSparTeamIdp :: PrepQuery R (Identity TeamId) RowSparTeamIdp
selectSparTeamIdp = "SELECT team, idp FROM team_idp WHERE team = ?"

readSparTeamIdp :: Env -> TeamId -> IO [RowSparTeamIdp]
readSparTeamIdp Env {..} tid =
  runClient envSpar $
    retry x1 (query selectSparTeamIdp (params Quorum (pure tid)))

readSparTeamIdpConduit :: Env -> TeamId -> ConduitM () [RowSparTeamIdp] IO ()
readSparTeamIdpConduit Env {..} tid =
  transPipe (runClient envSpar) $
    paginateC selectSparTeamIdp (paramsP Quorum (pure tid) envPageSize) x5

insertSparTeamIdp :: Env -> FilePath -> IO ()
insertSparTeamIdp _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparTeamIdp';
  -- run Client action on each.
  pure ()

-- spar.team_provisioning_by_team

type RowSparTeamProvisioningByTeam = (Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe Text, Maybe UUID, Maybe Text)

selectSparTeamProvisioningByTeam :: PrepQuery R (Identity TeamId) RowSparTeamProvisioningByTeam
selectSparTeamProvisioningByTeam = "SELECT team, id, created_at, descr, idp, token_ FROM team_provisioning_by_team WHERE team = ?"

readSparTeamProvisioningByTeam :: Env -> TeamId -> IO [RowSparTeamProvisioningByTeam]
readSparTeamProvisioningByTeam Env {..} tid =
  runClient envSpar $
    retry x1 (query selectSparTeamProvisioningByTeam (params Quorum (pure tid)))

readSparTeamProvisioningByTeamConduit :: Env -> TeamId -> ConduitM () [RowSparTeamProvisioningByTeam] IO ()
readSparTeamProvisioningByTeamConduit Env {..} tid =
  transPipe (runClient envSpar) $
    paginateC selectSparTeamProvisioningByTeam (paramsP Quorum (pure tid) envPageSize) x5

insertSparTeamProvisioningByTeam :: Env -> FilePath -> IO ()
insertSparTeamProvisioningByTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparTeamProvisioningByTeam';
  -- run Client action on each.
  pure ()

-- spar.team_provisioning_by_token

type RowSparTeamProvisioningByToken = (Maybe Text, Maybe UTCTime, Maybe Text, Maybe UUID, Maybe UUID, Maybe UUID)

selectSparTeamProvisioningByToken :: PrepQuery R (Identity TeamId) RowSparTeamProvisioningByToken
selectSparTeamProvisioningByToken = "SELECT token_, created_at, descr, id, idp, team FROM team_provisioning_by_token WHERE team = ?"

readSparTeamProvisioningByToken :: Env -> TeamId -> IO [RowSparTeamProvisioningByToken]
readSparTeamProvisioningByToken Env {..} tid =
  runClient envSpar $
    retry x1 (query selectSparTeamProvisioningByToken (params Quorum (pure tid)))

readSparTeamProvisioningByTokenConduit :: Env -> TeamId -> ConduitM () [RowSparTeamProvisioningByToken] IO ()
readSparTeamProvisioningByTokenConduit Env {..} tid =
  transPipe (runClient envSpar) $
    paginateC selectSparTeamProvisioningByToken (paramsP Quorum (pure tid) envPageSize) x5

insertSparTeamProvisioningByToken :: Env -> FilePath -> IO ()
insertSparTeamProvisioningByToken _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparTeamProvisioningByToken';
  -- run Client action on each.
  pure ()

-- spar.user

type RowSparUser = (Maybe Text, Maybe Text, Maybe UUID)

selectSparUser :: PrepQuery R (Identity ([UserId])) RowSparUser
selectSparUser = "SELECT issuer, sso_id, uid FROM user WHERE user in ?"

readSparUser :: Env -> [UserId] -> IO [RowSparUser]
readSparUser Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparUser (params Quorum (pure uids)))

readSparUserConduit :: Env -> [UserId] -> ConduitM () [RowSparUser] IO ()
readSparUserConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparUser (paramsP Quorum (pure uids) envPageSize) x5

insertSparUser :: Env -> FilePath -> IO ()
insertSparUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparUser';
  -- run Client action on each.
  pure ()

insertAllTables :: Env -> IO ()
insertAllTables env = do
  insertBrigActivationKeys env "brig.activation_keys"
  insertBrigClients env "brig.clients"
  insertBrigCodes env "brig.codes"
  insertBrigConnection env "brig.connection"
  insertBrigIdMapping env "brig.id_mapping"
  insertBrigInvitation env "brig.invitation"
  insertBrigInvitationInfo env "brig.invitation_info"
  insertBrigInviteeInfo env "brig.invitee_info"
  insertBrigLoginCodes env "brig.login_codes"
  insertBrigPasswordReset env "brig.password_reset"
  insertBrigPrekeys env "brig.prekeys"
  insertBrigProperties env "brig.properties"
  insertBrigRichInfo env "brig.rich_info"
  insertBrigTeamInvitation env "brig.team_invitation"
  insertBrigTeamInvitationEmail env "brig.team_invitation_email"
  insertBrigTeamInvitationInfo env "brig.team_invitation_info"
  insertBrigUser env "brig.user"
  insertBrigUserCookies env "brig.user_cookies"
  insertBrigUserHandle env "brig.user_handle"
  insertBrigUserKeys env "brig.user_keys"
  insertBrigUserKeysHash env "brig.user_keys_hash"
  insertGalleyBillingTeamMember env "galley.billing_team_member"
  insertGalleyClients env "galley.clients"
  insertGalleyConversation env "galley.conversation"
  insertGalleyLegalholdPendingPrekeys env "galley.legalhold_pending_prekeys"
  insertGalleyLegalholdService env "galley.legalhold_service"
  insertGalleyMember env "galley.member"
  insertGalleyTeam env "galley.team"
  insertGalleyTeamConv env "galley.team_conv"
  insertGalleyTeamFeatures env "galley.team_features"
  insertGalleyTeamMember env "galley.team_member"
  insertGalleyTeamNotifications env "galley.team_notifications"
  insertGalleyUser env "galley.user"
  insertGalleyUserTeam env "galley.user_team"
  insertGundeckNotifications env "gundeck.notifications"
  insertGundeckPush env "gundeck.push"
  insertGundeckUserPush env "gundeck.user_push"
  insertSparBindCookie env "spar.bind_cookie"
  insertSparIdp env "spar.idp"
  insertSparScimExternalIds env "spar.scim_external_ids"
  insertSparScimUserTimes env "spar.scim_user_times"
  insertSparTeamIdp env "spar.team_idp"
  insertSparTeamProvisioningByTeam env "spar.team_provisioning_by_team"
  insertSparTeamProvisioningByToken env "spar.team_provisioning_by_token"
  insertSparUser env "spar.user"
