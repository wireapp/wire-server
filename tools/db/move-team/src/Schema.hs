{-# LANGUAGE RecordWildCards #-}

-- This file is part of the Wire Server implementation.
--
-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>
--
-- This program is free software: you can redistribute it and/or modify it under
-- the terms of the GNU Affero General Public License as published by the Free
-- Software Foundation, either version 3 of the License, or (at your option) any
-- later version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
-- details.
--
-- You should have received a copy of the GNU Affero General Public License along
-- with this program. If not, see <https://www.gnu.org/licenses/>.

module Schema where

import Cassandra
import Common
import Data.Conduit
import Data.Handle (Handle)
import Data.IP (IP)
import Data.Id
import Data.Time
import Data.UUID
import Galley.Data.Instances ()
import Imports
import System.FilePath.Posix ((</>))
import Types
import Wire.API.Team.Permission
import Wire.API.User.Password (PasswordResetKey)

-- This file was autogenerated by gen-table-types

-- brig.clients

type RowBrigClients = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text, Maybe IP, Maybe Text, Maybe Double, Maybe Double, Maybe Text, Maybe UTCTime, Maybe Int32)

selectBrigClients :: PrepQuery R (Identity ([UserId])) RowBrigClients
selectBrigClients = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigClients :: Env -> [UserId] -> IO [RowBrigClients]
readBrigClients Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigClients (params Quorum (pure (uids))))

readBrigClientsConduit :: Env -> [UserId] -> ConduitM () [RowBrigClients] IO ()
readBrigClientsConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigClients (paramsP Quorum (pure uids) envPageSize) x5

selectBrigClientsAll :: PrepQuery R () RowBrigClients
selectBrigClientsAll = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients"

readBrigClientsConduitAll :: Env -> ConduitM () [RowBrigClients] IO ()
readBrigClientsConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigClientsAll (paramsP Quorum () envPageSize) x5

exportBrigClientsFull :: Env -> FilePath -> IO ()
exportBrigClientsFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.clients" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigClientsConduitAll env
        .| sinkLines handle

insertBrigClients :: PrepQuery W RowBrigClients ()
insertBrigClients =
  "INSERT INTO clients (user, client, class, cookie, ip, label, lat, lon, model, tstamp, type) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

importBrigClients :: Env -> FilePath -> IO ()
importBrigClients Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.clients"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigClients)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.connection

type RowBrigConnection = (Maybe UUID, Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe Text, Maybe Int32)

selectBrigConnection :: PrepQuery R (Identity ([UserId])) RowBrigConnection
selectBrigConnection = "SELECT left, right, conv, last_update, message, status FROM connection WHERE left in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigConnection :: Env -> [UserId] -> IO [RowBrigConnection]
readBrigConnection Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigConnection (params Quorum (pure (uids))))

readBrigConnectionConduit :: Env -> [UserId] -> ConduitM () [RowBrigConnection] IO ()
readBrigConnectionConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigConnection (paramsP Quorum (pure uids) envPageSize) x5

selectBrigConnectionAll :: PrepQuery R () RowBrigConnection
selectBrigConnectionAll = "SELECT left, right, conv, last_update, message, status FROM connection"

readBrigConnectionConduitAll :: Env -> ConduitM () [RowBrigConnection] IO ()
readBrigConnectionConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigConnectionAll (paramsP Quorum () envPageSize) x5

exportBrigConnectionFull :: Env -> FilePath -> IO ()
exportBrigConnectionFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.connection" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigConnectionConduitAll env
        .| sinkLines handle

insertBrigConnection :: PrepQuery W RowBrigConnection ()
insertBrigConnection =
  "INSERT INTO connection (left, right, conv, last_update, message, status) VALUES (?, ?, ?, ?, ?, ?)"

importBrigConnection :: Env -> FilePath -> IO ()
importBrigConnection Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.connection"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigConnection)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.id_mapping

type RowBrigIdMapping = (Maybe UUID, Maybe Text, Maybe UUID)

selectBrigIdMapping :: PrepQuery R (Identity ([UserId])) RowBrigIdMapping
selectBrigIdMapping = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping WHERE mapped_id in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigIdMapping :: Env -> [UserId] -> IO [RowBrigIdMapping]
readBrigIdMapping Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigIdMapping (params Quorum (pure (uids))))

readBrigIdMappingConduit :: Env -> [UserId] -> ConduitM () [RowBrigIdMapping] IO ()
readBrigIdMappingConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigIdMapping (paramsP Quorum (pure uids) envPageSize) x5

selectBrigIdMappingAll :: PrepQuery R () RowBrigIdMapping
selectBrigIdMappingAll = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping"

readBrigIdMappingConduitAll :: Env -> ConduitM () [RowBrigIdMapping] IO ()
readBrigIdMappingConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigIdMappingAll (paramsP Quorum () envPageSize) x5

exportBrigIdMappingFull :: Env -> FilePath -> IO ()
exportBrigIdMappingFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.id_mapping" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigIdMappingConduitAll env
        .| sinkLines handle

insertBrigIdMapping :: PrepQuery W RowBrigIdMapping ()
insertBrigIdMapping =
  "INSERT INTO id_mapping (mapped_id, remote_domain, remote_id) VALUES (?, ?, ?)"

importBrigIdMapping :: Env -> FilePath -> IO ()
importBrigIdMapping Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.id_mapping"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigIdMapping)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.login_codes

type RowBrigLoginCodes = (Maybe UUID, Maybe Text, Maybe Int32, Maybe UTCTime)

selectBrigLoginCodes :: PrepQuery R (Identity ([UserId])) RowBrigLoginCodes
selectBrigLoginCodes = "SELECT user, code, retries, timeout FROM login_codes WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigLoginCodes :: Env -> [UserId] -> IO [RowBrigLoginCodes]
readBrigLoginCodes Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigLoginCodes (params Quorum (pure (uids))))

readBrigLoginCodesConduit :: Env -> [UserId] -> ConduitM () [RowBrigLoginCodes] IO ()
readBrigLoginCodesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigLoginCodes (paramsP Quorum (pure uids) envPageSize) x5

selectBrigLoginCodesAll :: PrepQuery R () RowBrigLoginCodes
selectBrigLoginCodesAll = "SELECT user, code, retries, timeout FROM login_codes"

readBrigLoginCodesConduitAll :: Env -> ConduitM () [RowBrigLoginCodes] IO ()
readBrigLoginCodesConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigLoginCodesAll (paramsP Quorum () envPageSize) x5

exportBrigLoginCodesFull :: Env -> FilePath -> IO ()
exportBrigLoginCodesFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.login_codes" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigLoginCodesConduitAll env
        .| sinkLines handle

insertBrigLoginCodes :: PrepQuery W RowBrigLoginCodes ()
insertBrigLoginCodes =
  "INSERT INTO login_codes (user, code, retries, timeout) VALUES (?, ?, ?, ?)"

importBrigLoginCodes :: Env -> FilePath -> IO ()
importBrigLoginCodes Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.login_codes"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigLoginCodes)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.password_reset

type RowBrigPasswordReset = (Maybe Ascii, Maybe Ascii, Maybe Int32, Maybe UTCTime, Maybe UUID)

selectBrigPasswordReset :: PrepQuery R (Identity ([PasswordResetKey])) RowBrigPasswordReset
selectBrigPasswordReset = "SELECT key, code, retries, timeout, user FROM password_reset WHERE key in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigPasswordReset :: Env -> [PasswordResetKey] -> IO [RowBrigPasswordReset]
readBrigPasswordReset Env {..} reset_keys =
  runClient envBrig $
    retry x1 (query selectBrigPasswordReset (params Quorum (pure (reset_keys))))

readBrigPasswordResetConduit :: Env -> [PasswordResetKey] -> ConduitM () [RowBrigPasswordReset] IO ()
readBrigPasswordResetConduit Env {..} reset_keys =
  transPipe (runClient envBrig) $
    paginateC selectBrigPasswordReset (paramsP Quorum (pure reset_keys) envPageSize) x5

selectBrigPasswordResetAll :: PrepQuery R () RowBrigPasswordReset
selectBrigPasswordResetAll = "SELECT key, code, retries, timeout, user FROM password_reset"

readBrigPasswordResetConduitAll :: Env -> ConduitM () [RowBrigPasswordReset] IO ()
readBrigPasswordResetConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigPasswordResetAll (paramsP Quorum () envPageSize) x5

exportBrigPasswordResetFull :: Env -> FilePath -> IO ()
exportBrigPasswordResetFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.password_reset" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigPasswordResetConduitAll env
        .| sinkLines handle

insertBrigPasswordReset :: PrepQuery W RowBrigPasswordReset ()
insertBrigPasswordReset =
  "INSERT INTO password_reset (key, code, retries, timeout, user) VALUES (?, ?, ?, ?, ?)"

importBrigPasswordReset :: Env -> FilePath -> IO ()
importBrigPasswordReset Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.password_reset"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigPasswordReset)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.prekeys

type RowBrigPrekeys = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text)

selectBrigPrekeys :: PrepQuery R (Identity ([UserId])) RowBrigPrekeys
selectBrigPrekeys = "SELECT user, client, key, data FROM prekeys WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigPrekeys :: Env -> [UserId] -> IO [RowBrigPrekeys]
readBrigPrekeys Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigPrekeys (params Quorum (pure (uids))))

readBrigPrekeysConduit :: Env -> [UserId] -> ConduitM () [RowBrigPrekeys] IO ()
readBrigPrekeysConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigPrekeys (paramsP Quorum (pure uids) envPageSize) x5

selectBrigPrekeysAll :: PrepQuery R () RowBrigPrekeys
selectBrigPrekeysAll = "SELECT user, client, key, data FROM prekeys"

readBrigPrekeysConduitAll :: Env -> ConduitM () [RowBrigPrekeys] IO ()
readBrigPrekeysConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigPrekeysAll (paramsP Quorum () envPageSize) x5

exportBrigPrekeysFull :: Env -> FilePath -> IO ()
exportBrigPrekeysFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.prekeys" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigPrekeysConduitAll env
        .| sinkLines handle

insertBrigPrekeys :: PrepQuery W RowBrigPrekeys ()
insertBrigPrekeys =
  "INSERT INTO prekeys (user, client, key, data) VALUES (?, ?, ?, ?)"

importBrigPrekeys :: Env -> FilePath -> IO ()
importBrigPrekeys Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.prekeys"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigPrekeys)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.properties

type RowBrigProperties = (Maybe UUID, Maybe Ascii, Maybe Blob)

selectBrigProperties :: PrepQuery R (Identity ([UserId])) RowBrigProperties
selectBrigProperties = "SELECT user, key, value FROM properties WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigProperties :: Env -> [UserId] -> IO [RowBrigProperties]
readBrigProperties Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigProperties (params Quorum (pure (uids))))

readBrigPropertiesConduit :: Env -> [UserId] -> ConduitM () [RowBrigProperties] IO ()
readBrigPropertiesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigProperties (paramsP Quorum (pure uids) envPageSize) x5

selectBrigPropertiesAll :: PrepQuery R () RowBrigProperties
selectBrigPropertiesAll = "SELECT user, key, value FROM properties"

readBrigPropertiesConduitAll :: Env -> ConduitM () [RowBrigProperties] IO ()
readBrigPropertiesConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigPropertiesAll (paramsP Quorum () envPageSize) x5

exportBrigPropertiesFull :: Env -> FilePath -> IO ()
exportBrigPropertiesFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.properties" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigPropertiesConduitAll env
        .| sinkLines handle

insertBrigProperties :: PrepQuery W RowBrigProperties ()
insertBrigProperties =
  "INSERT INTO properties (user, key, value) VALUES (?, ?, ?)"

importBrigProperties :: Env -> FilePath -> IO ()
importBrigProperties Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.properties"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigProperties)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.rich_info

type RowBrigRichInfo = (Maybe UUID, Maybe Blob)

selectBrigRichInfo :: PrepQuery R (Identity ([UserId])) RowBrigRichInfo
selectBrigRichInfo = "SELECT user, json FROM rich_info WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigRichInfo :: Env -> [UserId] -> IO [RowBrigRichInfo]
readBrigRichInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigRichInfo (params Quorum (pure (uids))))

readBrigRichInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigRichInfo] IO ()
readBrigRichInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigRichInfo (paramsP Quorum (pure uids) envPageSize) x5

selectBrigRichInfoAll :: PrepQuery R () RowBrigRichInfo
selectBrigRichInfoAll = "SELECT user, json FROM rich_info"

readBrigRichInfoConduitAll :: Env -> ConduitM () [RowBrigRichInfo] IO ()
readBrigRichInfoConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigRichInfoAll (paramsP Quorum () envPageSize) x5

exportBrigRichInfoFull :: Env -> FilePath -> IO ()
exportBrigRichInfoFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.rich_info" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigRichInfoConduitAll env
        .| sinkLines handle

insertBrigRichInfo :: PrepQuery W RowBrigRichInfo ()
insertBrigRichInfo =
  "INSERT INTO rich_info (user, json) VALUES (?, ?)"

importBrigRichInfo :: Env -> FilePath -> IO ()
importBrigRichInfo Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.rich_info"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigRichInfo)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.user

type RowBrigUser = (Maybe UUID, Maybe [Float], Maybe Int32, Maybe Bool, Maybe [AssetIgnoreData], Maybe Ascii, Maybe Text, Maybe UTCTime, Maybe Text, Maybe Ascii, Maybe Int32, Maybe Text, Maybe Blob, Maybe Text, Maybe [Blob], Maybe UUID, Maybe Bool, Maybe UUID, Maybe Text, Maybe Int32, Maybe UUID)

selectBrigUser :: PrepQuery R (Identity ([UserId])) RowBrigUser
selectBrigUser = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user WHERE id in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigUser :: Env -> [UserId] -> IO [RowBrigUser]
readBrigUser Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUser (params Quorum (pure (uids))))

readBrigUserConduit :: Env -> [UserId] -> ConduitM () [RowBrigUser] IO ()
readBrigUserConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUser (paramsP Quorum (pure uids) envPageSize) x5

selectBrigUserAll :: PrepQuery R () RowBrigUser
selectBrigUserAll = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user"

readBrigUserConduitAll :: Env -> ConduitM () [RowBrigUser] IO ()
readBrigUserConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserAll (paramsP Quorum () envPageSize) x5

exportBrigUserFull :: Env -> FilePath -> IO ()
exportBrigUserFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.user" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigUserConduitAll env
        .| sinkLines handle

insertBrigUser :: PrepQuery W RowBrigUser ()
insertBrigUser =
  "INSERT INTO user (id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

importBrigUser :: Env -> FilePath -> IO ()
importBrigUser Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.user"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigUser)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- brig.user_handle

type RowBrigUserHandle = (Maybe Text, Maybe UUID)

selectBrigUserHandle :: PrepQuery R (Identity ([Handle])) RowBrigUserHandle
selectBrigUserHandle = "SELECT handle, user FROM user_handle WHERE handle in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigUserHandle :: Env -> [Handle] -> IO [RowBrigUserHandle]
readBrigUserHandle Env {..} handles =
  runClient envBrig $
    retry x1 (query selectBrigUserHandle (params Quorum (pure (handles))))

readBrigUserHandleConduit :: Env -> [Handle] -> ConduitM () [RowBrigUserHandle] IO ()
readBrigUserHandleConduit Env {..} handles =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserHandle (paramsP Quorum (pure handles) envPageSize) x5

selectBrigUserHandleAll :: PrepQuery R () RowBrigUserHandle
selectBrigUserHandleAll = "SELECT handle, user FROM user_handle"

readBrigUserHandleConduitAll :: Env -> ConduitM () [RowBrigUserHandle] IO ()
readBrigUserHandleConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserHandleAll (paramsP Quorum () envPageSize) x5

exportBrigUserHandleFull :: Env -> FilePath -> IO ()
exportBrigUserHandleFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "brig.user_handle" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readBrigUserHandleConduitAll env
        .| sinkLines handle

insertBrigUserHandle :: PrepQuery W RowBrigUserHandle ()
insertBrigUserHandle =
  "INSERT INTO user_handle (handle, user) VALUES (?, ?)"

importBrigUserHandle :: Env -> FilePath -> IO ()
importBrigUserHandle Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "brig.user_handle"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envBrig) (sinkRows insertBrigUserHandle)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.billing_team_member

type RowGalleyBillingTeamMember = (Maybe UUID, Maybe UUID)

selectGalleyBillingTeamMember :: PrepQuery R (Identity (TeamId)) RowGalleyBillingTeamMember
selectGalleyBillingTeamMember = "SELECT team, user FROM billing_team_member WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyBillingTeamMember :: Env -> TeamId -> IO [RowGalleyBillingTeamMember]
readGalleyBillingTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyBillingTeamMember (params Quorum (pure (tid))))

readGalleyBillingTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyBillingTeamMember] IO ()
readGalleyBillingTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyBillingTeamMember (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyBillingTeamMemberAll :: PrepQuery R () RowGalleyBillingTeamMember
selectGalleyBillingTeamMemberAll = "SELECT team, user FROM billing_team_member"

readGalleyBillingTeamMemberConduitAll :: Env -> ConduitM () [RowGalleyBillingTeamMember] IO ()
readGalleyBillingTeamMemberConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyBillingTeamMemberAll (paramsP Quorum () envPageSize) x5

exportGalleyBillingTeamMemberFull :: Env -> FilePath -> IO ()
exportGalleyBillingTeamMemberFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.billing_team_member" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyBillingTeamMemberConduitAll env
        .| sinkLines handle

insertGalleyBillingTeamMember :: PrepQuery W RowGalleyBillingTeamMember ()
insertGalleyBillingTeamMember =
  "INSERT INTO billing_team_member (team, user) VALUES (?, ?)"

importGalleyBillingTeamMember :: Env -> FilePath -> IO ()
importGalleyBillingTeamMember Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.billing_team_member"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyBillingTeamMember)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.clients

type RowGalleyClients = (Maybe UUID, Maybe (Cassandra.Set Text))

selectGalleyClients :: PrepQuery R (Identity ([UserId])) RowGalleyClients
selectGalleyClients = "SELECT user, clients FROM clients WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyClients :: Env -> [UserId] -> IO [RowGalleyClients]
readGalleyClients Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyClients (params Quorum (pure (uids))))

readGalleyClientsConduit :: Env -> [UserId] -> ConduitM () [RowGalleyClients] IO ()
readGalleyClientsConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyClients (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyClientsAll :: PrepQuery R () RowGalleyClients
selectGalleyClientsAll = "SELECT user, clients FROM clients"

readGalleyClientsConduitAll :: Env -> ConduitM () [RowGalleyClients] IO ()
readGalleyClientsConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyClientsAll (paramsP Quorum () envPageSize) x5

exportGalleyClientsFull :: Env -> FilePath -> IO ()
exportGalleyClientsFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.clients" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyClientsConduitAll env
        .| sinkLines handle

insertGalleyClients :: PrepQuery W RowGalleyClients ()
insertGalleyClients =
  "INSERT INTO clients (user, clients) VALUES (?, ?)"

importGalleyClients :: Env -> FilePath -> IO ()
importGalleyClients Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.clients"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyClients)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.conversation

type RowGalleyConversation = (Maybe UUID, Maybe (Cassandra.Set Int32), Maybe Int32, Maybe UUID, Maybe Bool, Maybe Int64, Maybe Text, Maybe Int32, Maybe UUID, Maybe Int32)

selectGalleyConversation :: PrepQuery R (Identity ([ConvId])) RowGalleyConversation
selectGalleyConversation = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation WHERE conv in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyConversation :: Env -> [ConvId] -> IO [RowGalleyConversation]
readGalleyConversation Env {..} cids =
  runClient envGalley $
    retry x1 (query selectGalleyConversation (params Quorum (pure (cids))))

readGalleyConversationConduit :: Env -> [ConvId] -> ConduitM () [RowGalleyConversation] IO ()
readGalleyConversationConduit Env {..} cids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyConversation (paramsP Quorum (pure cids) envPageSize) x5

selectGalleyConversationAll :: PrepQuery R () RowGalleyConversation
selectGalleyConversationAll = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation"

readGalleyConversationConduitAll :: Env -> ConduitM () [RowGalleyConversation] IO ()
readGalleyConversationConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyConversationAll (paramsP Quorum () envPageSize) x5

exportGalleyConversationFull :: Env -> FilePath -> IO ()
exportGalleyConversationFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.conversation" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyConversationConduitAll env
        .| sinkLines handle

insertGalleyConversation :: PrepQuery W RowGalleyConversation ()
insertGalleyConversation =
  "INSERT INTO conversation (conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

importGalleyConversation :: Env -> FilePath -> IO ()
importGalleyConversation Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.conversation"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyConversation)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.member

type RowGalleyMember = (Maybe UUID, Maybe UUID, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Int32, Maybe UUID, Maybe UUID, Maybe Int32, Maybe Text, Maybe UUID)

selectGalleyMember :: PrepQuery R (Identity ([ConvId])) RowGalleyMember
selectGalleyMember = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member WHERE conv in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyMember :: Env -> [ConvId] -> IO [RowGalleyMember]
readGalleyMember Env {..} cids =
  runClient envGalley $
    retry x1 (query selectGalleyMember (params Quorum (pure (cids))))

readGalleyMemberConduit :: Env -> [ConvId] -> ConduitM () [RowGalleyMember] IO ()
readGalleyMemberConduit Env {..} cids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyMember (paramsP Quorum (pure cids) envPageSize) x5

selectGalleyMemberAll :: PrepQuery R () RowGalleyMember
selectGalleyMemberAll = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member"

readGalleyMemberConduitAll :: Env -> ConduitM () [RowGalleyMember] IO ()
readGalleyMemberConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyMemberAll (paramsP Quorum () envPageSize) x5

exportGalleyMemberFull :: Env -> FilePath -> IO ()
exportGalleyMemberFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.member" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyMemberConduitAll env
        .| sinkLines handle

insertGalleyMember :: PrepQuery W RowGalleyMember ()
insertGalleyMember =
  "INSERT INTO member (conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

importGalleyMember :: Env -> FilePath -> IO ()
importGalleyMember Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.member"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyMember)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.team

type RowGalleyTeam = (Maybe UUID, Maybe Bool, Maybe UUID, Maybe Bool, Maybe Text, Maybe Text, Maybe Text, Maybe Int32, Maybe Int32)

selectGalleyTeam :: PrepQuery R (Identity (TeamId)) RowGalleyTeam
selectGalleyTeam = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeam :: Env -> TeamId -> IO [RowGalleyTeam]
readGalleyTeam Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeam (params Quorum (pure (tid))))

readGalleyTeamConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeam] IO ()
readGalleyTeamConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeam (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamAll :: PrepQuery R () RowGalleyTeam
selectGalleyTeamAll = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team"

readGalleyTeamConduitAll :: Env -> ConduitM () [RowGalleyTeam] IO ()
readGalleyTeamConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamAll (paramsP Quorum () envPageSize) x5

exportGalleyTeamFull :: Env -> FilePath -> IO ()
exportGalleyTeamFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.team" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyTeamConduitAll env
        .| sinkLines handle

insertGalleyTeam :: PrepQuery W RowGalleyTeam ()
insertGalleyTeam =
  "INSERT INTO team (team, binding, creator, deleted, icon, icon_key, name, search_visibility, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"

importGalleyTeam :: Env -> FilePath -> IO ()
importGalleyTeam Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.team"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyTeam)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.team_conv

type RowGalleyTeamConv = (Maybe UUID, Maybe UUID, Maybe Bool)

selectGalleyTeamConv :: PrepQuery R (Identity (TeamId)) RowGalleyTeamConv
selectGalleyTeamConv = "SELECT team, conv, managed FROM team_conv WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamConv :: Env -> TeamId -> IO [RowGalleyTeamConv]
readGalleyTeamConv Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamConv (params Quorum (pure (tid))))

readGalleyTeamConvConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamConv] IO ()
readGalleyTeamConvConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamConv (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamConvAll :: PrepQuery R () RowGalleyTeamConv
selectGalleyTeamConvAll = "SELECT team, conv, managed FROM team_conv"

readGalleyTeamConvConduitAll :: Env -> ConduitM () [RowGalleyTeamConv] IO ()
readGalleyTeamConvConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamConvAll (paramsP Quorum () envPageSize) x5

exportGalleyTeamConvFull :: Env -> FilePath -> IO ()
exportGalleyTeamConvFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.team_conv" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyTeamConvConduitAll env
        .| sinkLines handle

insertGalleyTeamConv :: PrepQuery W RowGalleyTeamConv ()
insertGalleyTeamConv =
  "INSERT INTO team_conv (team, conv, managed) VALUES (?, ?, ?)"

importGalleyTeamConv :: Env -> FilePath -> IO ()
importGalleyTeamConv Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.team_conv"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyTeamConv)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.team_features

type RowGalleyTeamFeatures = (Maybe UUID, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32)

selectGalleyTeamFeatures :: PrepQuery R (Identity (TeamId)) RowGalleyTeamFeatures
selectGalleyTeamFeatures = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features WHERE team_id = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamFeatures :: Env -> TeamId -> IO [RowGalleyTeamFeatures]
readGalleyTeamFeatures Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamFeatures (params Quorum (pure (tid))))

readGalleyTeamFeaturesConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamFeatures] IO ()
readGalleyTeamFeaturesConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamFeatures (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamFeaturesAll :: PrepQuery R () RowGalleyTeamFeatures
selectGalleyTeamFeaturesAll = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features"

readGalleyTeamFeaturesConduitAll :: Env -> ConduitM () [RowGalleyTeamFeatures] IO ()
readGalleyTeamFeaturesConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamFeaturesAll (paramsP Quorum () envPageSize) x5

exportGalleyTeamFeaturesFull :: Env -> FilePath -> IO ()
exportGalleyTeamFeaturesFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.team_features" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyTeamFeaturesConduitAll env
        .| sinkLines handle

insertGalleyTeamFeatures :: PrepQuery W RowGalleyTeamFeatures ()
insertGalleyTeamFeatures =
  "INSERT INTO team_features (team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails) VALUES (?, ?, ?, ?, ?, ?)"

importGalleyTeamFeatures :: Env -> FilePath -> IO ()
importGalleyTeamFeatures Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.team_features"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyTeamFeatures)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.team_member

type RowGalleyTeamMember = (Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe UUID, Maybe Int32, Maybe Permissions)

selectGalleyTeamMember :: PrepQuery R (Identity (TeamId)) RowGalleyTeamMember
selectGalleyTeamMember = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamMember :: Env -> TeamId -> IO [RowGalleyTeamMember]
readGalleyTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamMember (params Quorum (pure (tid))))

readGalleyTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamMember] IO ()
readGalleyTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamMember (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamMemberAll :: PrepQuery R () RowGalleyTeamMember
selectGalleyTeamMemberAll = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member"

readGalleyTeamMemberConduitAll :: Env -> ConduitM () [RowGalleyTeamMember] IO ()
readGalleyTeamMemberConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamMemberAll (paramsP Quorum () envPageSize) x5

exportGalleyTeamMemberFull :: Env -> FilePath -> IO ()
exportGalleyTeamMemberFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.team_member" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyTeamMemberConduitAll env
        .| sinkLines handle

insertGalleyTeamMember :: PrepQuery W RowGalleyTeamMember ()
insertGalleyTeamMember =
  "INSERT INTO team_member (team, user, invited_at, invited_by, legalhold_status, perms) VALUES (?, ?, ?, ?, ?, ?)"

importGalleyTeamMember :: Env -> FilePath -> IO ()
importGalleyTeamMember Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.team_member"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyTeamMember)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.team_notifications

type RowGalleyTeamNotifications = (Maybe UUID, Maybe TimeUuid, Maybe Blob)

selectGalleyTeamNotifications :: PrepQuery R (Identity (TeamId)) RowGalleyTeamNotifications
selectGalleyTeamNotifications = "SELECT team, id, payload FROM team_notifications WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamNotifications :: Env -> TeamId -> IO [RowGalleyTeamNotifications]
readGalleyTeamNotifications Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamNotifications (params Quorum (pure (tid))))

readGalleyTeamNotificationsConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamNotifications] IO ()
readGalleyTeamNotificationsConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamNotifications (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamNotificationsAll :: PrepQuery R () RowGalleyTeamNotifications
selectGalleyTeamNotificationsAll = "SELECT team, id, payload FROM team_notifications"

readGalleyTeamNotificationsConduitAll :: Env -> ConduitM () [RowGalleyTeamNotifications] IO ()
readGalleyTeamNotificationsConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamNotificationsAll (paramsP Quorum () envPageSize) x5

exportGalleyTeamNotificationsFull :: Env -> FilePath -> IO ()
exportGalleyTeamNotificationsFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.team_notifications" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyTeamNotificationsConduitAll env
        .| sinkLines handle

insertGalleyTeamNotifications :: PrepQuery W RowGalleyTeamNotifications ()
insertGalleyTeamNotifications =
  "INSERT INTO team_notifications (team, id, payload) VALUES (?, ?, ?)"

importGalleyTeamNotifications :: Env -> FilePath -> IO ()
importGalleyTeamNotifications Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.team_notifications"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyTeamNotifications)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.user

type RowGalleyUser = (Maybe UUID, Maybe UUID, Maybe Text, Maybe UUID)

selectGalleyUser :: PrepQuery R (Identity ([UserId])) RowGalleyUser
selectGalleyUser = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyUser :: Env -> [UserId] -> IO [RowGalleyUser]
readGalleyUser Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUser (params Quorum (pure (uids))))

readGalleyUserConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUser] IO ()
readGalleyUserConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUser (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyUserAll :: PrepQuery R () RowGalleyUser
selectGalleyUserAll = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user"

readGalleyUserConduitAll :: Env -> ConduitM () [RowGalleyUser] IO ()
readGalleyUserConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserAll (paramsP Quorum () envPageSize) x5

exportGalleyUserFull :: Env -> FilePath -> IO ()
exportGalleyUserFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.user" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyUserConduitAll env
        .| sinkLines handle

insertGalleyUser :: PrepQuery W RowGalleyUser ()
insertGalleyUser =
  "INSERT INTO user (user, conv, conv_remote_domain, conv_remote_id) VALUES (?, ?, ?, ?)"

importGalleyUser :: Env -> FilePath -> IO ()
importGalleyUser Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.user"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyUser)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- galley.user_team

type RowGalleyUserTeam = (Maybe UUID, Maybe UUID)

selectGalleyUserTeam :: PrepQuery R (Identity ([UserId])) RowGalleyUserTeam
selectGalleyUserTeam = "SELECT user, team FROM user_team WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyUserTeam :: Env -> [UserId] -> IO [RowGalleyUserTeam]
readGalleyUserTeam Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUserTeam (params Quorum (pure (uids))))

readGalleyUserTeamConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUserTeam] IO ()
readGalleyUserTeamConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserTeam (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyUserTeamAll :: PrepQuery R () RowGalleyUserTeam
selectGalleyUserTeamAll = "SELECT user, team FROM user_team"

readGalleyUserTeamConduitAll :: Env -> ConduitM () [RowGalleyUserTeam] IO ()
readGalleyUserTeamConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserTeamAll (paramsP Quorum () envPageSize) x5

exportGalleyUserTeamFull :: Env -> FilePath -> IO ()
exportGalleyUserTeamFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "galley.user_team" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGalleyUserTeamConduitAll env
        .| sinkLines handle

insertGalleyUserTeam :: PrepQuery W RowGalleyUserTeam ()
insertGalleyUserTeam =
  "INSERT INTO user_team (user, team) VALUES (?, ?)"

importGalleyUserTeam :: Env -> FilePath -> IO ()
importGalleyUserTeam Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "galley.user_team"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGalley) (sinkRows insertGalleyUserTeam)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- gundeck.notifications

type RowGundeckNotifications = (Maybe UUID, Maybe TimeUuid, Maybe (Cassandra.Set Text), Maybe Blob)

selectGundeckNotifications :: PrepQuery R (Identity ([UserId])) RowGundeckNotifications
selectGundeckNotifications = "SELECT user, id, clients, payload FROM notifications WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGundeckNotifications :: Env -> [UserId] -> IO [RowGundeckNotifications]
readGundeckNotifications Env {..} uids =
  runClient envGundeck $
    retry x1 (query selectGundeckNotifications (params Quorum (pure (uids))))

readGundeckNotificationsConduit :: Env -> [UserId] -> ConduitM () [RowGundeckNotifications] IO ()
readGundeckNotificationsConduit Env {..} uids =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckNotifications (paramsP Quorum (pure uids) envPageSize) x5

selectGundeckNotificationsAll :: PrepQuery R () RowGundeckNotifications
selectGundeckNotificationsAll = "SELECT user, id, clients, payload FROM notifications"

readGundeckNotificationsConduitAll :: Env -> ConduitM () [RowGundeckNotifications] IO ()
readGundeckNotificationsConduitAll Env {..} =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckNotificationsAll (paramsP Quorum () envPageSize) x5

exportGundeckNotificationsFull :: Env -> FilePath -> IO ()
exportGundeckNotificationsFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "gundeck.notifications" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readGundeckNotificationsConduitAll env
        .| sinkLines handle

insertGundeckNotifications :: PrepQuery W RowGundeckNotifications ()
insertGundeckNotifications =
  "INSERT INTO notifications (user, id, clients, payload) VALUES (?, ?, ?, ?)"

importGundeckNotifications :: Env -> FilePath -> IO ()
importGundeckNotifications Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "gundeck.notifications"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envGundeck) (sinkRows insertGundeckNotifications)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

-- spar.scim_user_times

type RowSparScimUserTimes = (Maybe UUID, Maybe UTCTime, Maybe UTCTime)

selectSparScimUserTimes :: PrepQuery R (Identity ([UserId])) RowSparScimUserTimes
selectSparScimUserTimes = "SELECT uid, created_at, last_updated_at FROM scim_user_times WHERE uid in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readSparScimUserTimes :: Env -> [UserId] -> IO [RowSparScimUserTimes]
readSparScimUserTimes Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparScimUserTimes (params Quorum (pure (uids))))

readSparScimUserTimesConduit :: Env -> [UserId] -> ConduitM () [RowSparScimUserTimes] IO ()
readSparScimUserTimesConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparScimUserTimes (paramsP Quorum (pure uids) envPageSize) x5

selectSparScimUserTimesAll :: PrepQuery R () RowSparScimUserTimes
selectSparScimUserTimesAll = "SELECT uid, created_at, last_updated_at FROM scim_user_times"

readSparScimUserTimesConduitAll :: Env -> ConduitM () [RowSparScimUserTimes] IO ()
readSparScimUserTimesConduitAll Env {..} =
  transPipe (runClient envSpar) $
    paginateC selectSparScimUserTimesAll (paramsP Quorum () envPageSize) x5

exportSparScimUserTimesFull :: Env -> FilePath -> IO ()
exportSparScimUserTimesFull env@Env {..} path = do
  putStrLn $ "Exporting " <> "spar.scim_user_times" <> " to " <> path
  withBinaryFile path WriteMode $ \handle ->
    runConduit $
      readSparScimUserTimesConduitAll env
        .| sinkLines handle

insertSparScimUserTimes :: PrepQuery W RowSparScimUserTimes ()
insertSparScimUserTimes =
  "INSERT INTO scim_user_times (uid, created_at, last_updated_at) VALUES (?, ?, ?)"

importSparScimUserTimes :: Env -> FilePath -> IO ()
importSparScimUserTimes Env {..} path = do
  exists <- doesFileExist path
  if exists
    then do
      putStrLn $ "Importing " <> path <> " to " <> "spar.scim_user_times"
      withBinaryFile path ReadMode $ \handle -> do
        runConduit $
          sourceJsonLines handle
            .| transPipe (runClient envSpar) (sinkRows insertSparScimUserTimes)
    else do
      putStrLn $ "Skipping because not found: " <> path
      pure ()

importAllTables :: Env -> IO ()
importAllTables env@Env {..} = do
  importBrigClients env (envTargetPath </> "brig.clients")
  importBrigConnection env (envTargetPath </> "brig.connection")
  importBrigIdMapping env (envTargetPath </> "brig.id_mapping")
  importBrigLoginCodes env (envTargetPath </> "brig.login_codes")
  importBrigPasswordReset env (envTargetPath </> "brig.password_reset")
  importBrigPrekeys env (envTargetPath </> "brig.prekeys")
  importBrigProperties env (envTargetPath </> "brig.properties")
  importBrigRichInfo env (envTargetPath </> "brig.rich_info")
  importBrigUser env (envTargetPath </> "brig.user")
  importBrigUserHandle env (envTargetPath </> "brig.user_handle")
  importGalleyBillingTeamMember env (envTargetPath </> "galley.billing_team_member")
  importGalleyClients env (envTargetPath </> "galley.clients")
  importGalleyConversation env (envTargetPath </> "galley.conversation")
  importGalleyMember env (envTargetPath </> "galley.member")
  importGalleyTeam env (envTargetPath </> "galley.team")
  importGalleyTeamConv env (envTargetPath </> "galley.team_conv")
  importGalleyTeamFeatures env (envTargetPath </> "galley.team_features")
  importGalleyTeamMember env (envTargetPath </> "galley.team_member")
  importGalleyTeamNotifications env (envTargetPath </> "galley.team_notifications")
  importGalleyUser env (envTargetPath </> "galley.user")
  importGalleyUserTeam env (envTargetPath </> "galley.user_team")
  importGundeckNotifications env (envTargetPath </> "gundeck.notifications")
  importSparScimUserTimes env (envTargetPath </> "spar.scim_user_times")

exportAllTables :: Env -> IO ()
exportAllTables env@Env {..} = do
  exportBrigClientsFull env (envTargetPath </> "brig.clients")
  exportBrigConnectionFull env (envTargetPath </> "brig.connection")
  exportBrigIdMappingFull env (envTargetPath </> "brig.id_mapping")
  exportBrigLoginCodesFull env (envTargetPath </> "brig.login_codes")
  exportBrigPasswordResetFull env (envTargetPath </> "brig.password_reset")
  exportBrigPrekeysFull env (envTargetPath </> "brig.prekeys")
  exportBrigPropertiesFull env (envTargetPath </> "brig.properties")
  exportBrigRichInfoFull env (envTargetPath </> "brig.rich_info")
  exportBrigUserFull env (envTargetPath </> "brig.user")
  exportBrigUserHandleFull env (envTargetPath </> "brig.user_handle")
  exportGalleyBillingTeamMemberFull env (envTargetPath </> "galley.billing_team_member")
  exportGalleyClientsFull env (envTargetPath </> "galley.clients")
  exportGalleyConversationFull env (envTargetPath </> "galley.conversation")
  exportGalleyMemberFull env (envTargetPath </> "galley.member")
  exportGalleyTeamFull env (envTargetPath </> "galley.team")
  exportGalleyTeamConvFull env (envTargetPath </> "galley.team_conv")
  exportGalleyTeamFeaturesFull env (envTargetPath </> "galley.team_features")
  exportGalleyTeamMemberFull env (envTargetPath </> "galley.team_member")
  exportGalleyTeamNotificationsFull env (envTargetPath </> "galley.team_notifications")
  exportGalleyUserFull env (envTargetPath </> "galley.user")
  exportGalleyUserTeamFull env (envTargetPath </> "galley.user_team")
  exportGundeckNotificationsFull env (envTargetPath </> "gundeck.notifications")
  exportSparScimUserTimesFull env (envTargetPath </> "spar.scim_user_times")
