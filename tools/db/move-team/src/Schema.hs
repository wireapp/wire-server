{-# LANGUAGE RecordWildCards #-}

-- This file is part of the Wire Server implementation.
--
-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>
--
-- This program is free software: you can redistribute it and/or modify it under
-- the terms of the GNU Affero General Public License as published by the Free
-- Software Foundation, either version 3 of the License, or (at your option) any
-- later version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
-- details.
--
-- You should have received a copy of the GNU Affero General Public License along
-- with this program. If not, see <https://www.gnu.org/licenses/>.

module Schema where

import Cassandra
import Data.Conduit
import Data.Handle (Handle)
import Data.IP (IP)
import Data.Id
import Data.Time
import Data.UUID
import Galley.Data.Instances ()
import Imports
import Types
import Wire.API.Team.Permission
import Wire.API.User.Password (PasswordResetKey)

-- This file was autogenerated by gen-table-types

-- brig.clients

type RowBrigClients = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text, Maybe IP, Maybe Text, Maybe Double, Maybe Double, Maybe Text, Maybe UTCTime, Maybe Int32)

selectBrigClients :: PrepQuery R (Identity ([UserId])) RowBrigClients
selectBrigClients = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigClients :: Env -> [UserId] -> IO [RowBrigClients]
readBrigClients Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigClients (params Quorum (pure (uids))))

readBrigClientsConduit :: Env -> [UserId] -> ConduitM () [RowBrigClients] IO ()
readBrigClientsConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigClients (paramsP Quorum (pure uids) envPageSize) x5

selectBrigClientsAll :: PrepQuery R () RowBrigClients
selectBrigClientsAll = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients"

readBrigClientsConduitAll :: Env -> ConduitM () [RowBrigClients] IO ()
readBrigClientsConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigClientsAll (paramsP Quorum () envPageSize) x5

insertBrigClients :: Env -> FilePath -> IO ()
insertBrigClients _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigClients';
  -- run Client action on each.
  pure ()

-- brig.connection

type RowBrigConnection = (Maybe UUID, Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe Text, Maybe Int32)

selectBrigConnection :: PrepQuery R (Identity ([UserId])) RowBrigConnection
selectBrigConnection = "SELECT left, right, conv, last_update, message, status FROM connection WHERE left in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigConnection :: Env -> [UserId] -> IO [RowBrigConnection]
readBrigConnection Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigConnection (params Quorum (pure (uids))))

readBrigConnectionConduit :: Env -> [UserId] -> ConduitM () [RowBrigConnection] IO ()
readBrigConnectionConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigConnection (paramsP Quorum (pure uids) envPageSize) x5

selectBrigConnectionAll :: PrepQuery R () RowBrigConnection
selectBrigConnectionAll = "SELECT left, right, conv, last_update, message, status FROM connection"

readBrigConnectionConduitAll :: Env -> ConduitM () [RowBrigConnection] IO ()
readBrigConnectionConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigConnectionAll (paramsP Quorum () envPageSize) x5

insertBrigConnection :: Env -> FilePath -> IO ()
insertBrigConnection _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigConnection';
  -- run Client action on each.
  pure ()

-- brig.id_mapping

type RowBrigIdMapping = (Maybe UUID, Maybe Text, Maybe UUID)

selectBrigIdMapping :: PrepQuery R (Identity ([UserId])) RowBrigIdMapping
selectBrigIdMapping = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping WHERE mapped_id in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigIdMapping :: Env -> [UserId] -> IO [RowBrigIdMapping]
readBrigIdMapping Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigIdMapping (params Quorum (pure (uids))))

readBrigIdMappingConduit :: Env -> [UserId] -> ConduitM () [RowBrigIdMapping] IO ()
readBrigIdMappingConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigIdMapping (paramsP Quorum (pure uids) envPageSize) x5

selectBrigIdMappingAll :: PrepQuery R () RowBrigIdMapping
selectBrigIdMappingAll = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping"

readBrigIdMappingConduitAll :: Env -> ConduitM () [RowBrigIdMapping] IO ()
readBrigIdMappingConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigIdMappingAll (paramsP Quorum () envPageSize) x5

insertBrigIdMapping :: Env -> FilePath -> IO ()
insertBrigIdMapping _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigIdMapping';
  -- run Client action on each.
  pure ()

-- brig.login_codes

type RowBrigLoginCodes = (Maybe UUID, Maybe Text, Maybe Int32, Maybe UTCTime)

selectBrigLoginCodes :: PrepQuery R (Identity ([UserId])) RowBrigLoginCodes
selectBrigLoginCodes = "SELECT user, code, retries, timeout FROM login_codes WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigLoginCodes :: Env -> [UserId] -> IO [RowBrigLoginCodes]
readBrigLoginCodes Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigLoginCodes (params Quorum (pure (uids))))

readBrigLoginCodesConduit :: Env -> [UserId] -> ConduitM () [RowBrigLoginCodes] IO ()
readBrigLoginCodesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigLoginCodes (paramsP Quorum (pure uids) envPageSize) x5

selectBrigLoginCodesAll :: PrepQuery R () RowBrigLoginCodes
selectBrigLoginCodesAll = "SELECT user, code, retries, timeout FROM login_codes"

readBrigLoginCodesConduitAll :: Env -> ConduitM () [RowBrigLoginCodes] IO ()
readBrigLoginCodesConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigLoginCodesAll (paramsP Quorum () envPageSize) x5

insertBrigLoginCodes :: Env -> FilePath -> IO ()
insertBrigLoginCodes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigLoginCodes';
  -- run Client action on each.
  pure ()

-- brig.password_reset

type RowBrigPasswordReset = (Maybe Ascii, Maybe Ascii, Maybe Int32, Maybe UTCTime, Maybe UUID)

selectBrigPasswordReset :: PrepQuery R (Identity ([PasswordResetKey])) RowBrigPasswordReset
selectBrigPasswordReset = "SELECT key, code, retries, timeout, user FROM password_reset WHERE key in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigPasswordReset :: Env -> [PasswordResetKey] -> IO [RowBrigPasswordReset]
readBrigPasswordReset Env {..} reset_keys =
  runClient envBrig $
    retry x1 (query selectBrigPasswordReset (params Quorum (pure (reset_keys))))

readBrigPasswordResetConduit :: Env -> [PasswordResetKey] -> ConduitM () [RowBrigPasswordReset] IO ()
readBrigPasswordResetConduit Env {..} reset_keys =
  transPipe (runClient envBrig) $
    paginateC selectBrigPasswordReset (paramsP Quorum (pure reset_keys) envPageSize) x5

selectBrigPasswordResetAll :: PrepQuery R () RowBrigPasswordReset
selectBrigPasswordResetAll = "SELECT key, code, retries, timeout, user FROM password_reset"

readBrigPasswordResetConduitAll :: Env -> ConduitM () [RowBrigPasswordReset] IO ()
readBrigPasswordResetConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigPasswordResetAll (paramsP Quorum () envPageSize) x5

insertBrigPasswordReset :: Env -> FilePath -> IO ()
insertBrigPasswordReset _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigPasswordReset';
  -- run Client action on each.
  pure ()

-- brig.prekeys

type RowBrigPrekeys = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text)

selectBrigPrekeys :: PrepQuery R (Identity ([UserId])) RowBrigPrekeys
selectBrigPrekeys = "SELECT user, client, key, data FROM prekeys WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigPrekeys :: Env -> [UserId] -> IO [RowBrigPrekeys]
readBrigPrekeys Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigPrekeys (params Quorum (pure (uids))))

readBrigPrekeysConduit :: Env -> [UserId] -> ConduitM () [RowBrigPrekeys] IO ()
readBrigPrekeysConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigPrekeys (paramsP Quorum (pure uids) envPageSize) x5

selectBrigPrekeysAll :: PrepQuery R () RowBrigPrekeys
selectBrigPrekeysAll = "SELECT user, client, key, data FROM prekeys"

readBrigPrekeysConduitAll :: Env -> ConduitM () [RowBrigPrekeys] IO ()
readBrigPrekeysConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigPrekeysAll (paramsP Quorum () envPageSize) x5

insertBrigPrekeys :: Env -> FilePath -> IO ()
insertBrigPrekeys _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigPrekeys';
  -- run Client action on each.
  pure ()

-- brig.properties

type RowBrigProperties = (Maybe UUID, Maybe Ascii, Maybe Blob)

selectBrigProperties :: PrepQuery R (Identity ([UserId])) RowBrigProperties
selectBrigProperties = "SELECT user, key, value FROM properties WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigProperties :: Env -> [UserId] -> IO [RowBrigProperties]
readBrigProperties Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigProperties (params Quorum (pure (uids))))

readBrigPropertiesConduit :: Env -> [UserId] -> ConduitM () [RowBrigProperties] IO ()
readBrigPropertiesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigProperties (paramsP Quorum (pure uids) envPageSize) x5

selectBrigPropertiesAll :: PrepQuery R () RowBrigProperties
selectBrigPropertiesAll = "SELECT user, key, value FROM properties"

readBrigPropertiesConduitAll :: Env -> ConduitM () [RowBrigProperties] IO ()
readBrigPropertiesConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigPropertiesAll (paramsP Quorum () envPageSize) x5

insertBrigProperties :: Env -> FilePath -> IO ()
insertBrigProperties _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigProperties';
  -- run Client action on each.
  pure ()

-- brig.rich_info

type RowBrigRichInfo = (Maybe UUID, Maybe Blob)

selectBrigRichInfo :: PrepQuery R (Identity ([UserId])) RowBrigRichInfo
selectBrigRichInfo = "SELECT user, json FROM rich_info WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigRichInfo :: Env -> [UserId] -> IO [RowBrigRichInfo]
readBrigRichInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigRichInfo (params Quorum (pure (uids))))

readBrigRichInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigRichInfo] IO ()
readBrigRichInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigRichInfo (paramsP Quorum (pure uids) envPageSize) x5

selectBrigRichInfoAll :: PrepQuery R () RowBrigRichInfo
selectBrigRichInfoAll = "SELECT user, json FROM rich_info"

readBrigRichInfoConduitAll :: Env -> ConduitM () [RowBrigRichInfo] IO ()
readBrigRichInfoConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigRichInfoAll (paramsP Quorum () envPageSize) x5

insertBrigRichInfo :: Env -> FilePath -> IO ()
insertBrigRichInfo _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigRichInfo';
  -- run Client action on each.
  pure ()

-- brig.user

type RowBrigUser = (Maybe UUID, Maybe [Float], Maybe Int32, Maybe Bool, Maybe [AssetIgnoreData], Maybe Ascii, Maybe Text, Maybe UTCTime, Maybe Text, Maybe Ascii, Maybe Int32, Maybe Text, Maybe Blob, Maybe Text, Maybe [Blob], Maybe UUID, Maybe Bool, Maybe UUID, Maybe Text, Maybe Int32, Maybe UUID)

selectBrigUser :: PrepQuery R (Identity ([UserId])) RowBrigUser
selectBrigUser = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user WHERE id in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigUser :: Env -> [UserId] -> IO [RowBrigUser]
readBrigUser Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUser (params Quorum (pure (uids))))

readBrigUserConduit :: Env -> [UserId] -> ConduitM () [RowBrigUser] IO ()
readBrigUserConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUser (paramsP Quorum (pure uids) envPageSize) x5

selectBrigUserAll :: PrepQuery R () RowBrigUser
selectBrigUserAll = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user"

readBrigUserConduitAll :: Env -> ConduitM () [RowBrigUser] IO ()
readBrigUserConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserAll (paramsP Quorum () envPageSize) x5

insertBrigUser :: Env -> FilePath -> IO ()
insertBrigUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUser';
  -- run Client action on each.
  pure ()

-- brig.user_handle

type RowBrigUserHandle = (Maybe Text, Maybe UUID)

selectBrigUserHandle :: PrepQuery R (Identity ([Handle])) RowBrigUserHandle
selectBrigUserHandle = "SELECT handle, user FROM user_handle WHERE handle in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readBrigUserHandle :: Env -> [Handle] -> IO [RowBrigUserHandle]
readBrigUserHandle Env {..} handles =
  runClient envBrig $
    retry x1 (query selectBrigUserHandle (params Quorum (pure (handles))))

readBrigUserHandleConduit :: Env -> [Handle] -> ConduitM () [RowBrigUserHandle] IO ()
readBrigUserHandleConduit Env {..} handles =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserHandle (paramsP Quorum (pure handles) envPageSize) x5

selectBrigUserHandleAll :: PrepQuery R () RowBrigUserHandle
selectBrigUserHandleAll = "SELECT handle, user FROM user_handle"

readBrigUserHandleConduitAll :: Env -> ConduitM () [RowBrigUserHandle] IO ()
readBrigUserHandleConduitAll Env {..} =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserHandleAll (paramsP Quorum () envPageSize) x5

insertBrigUserHandle :: Env -> FilePath -> IO ()
insertBrigUserHandle _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUserHandle';
  -- run Client action on each.
  pure ()

-- galley.billing_team_member

type RowGalleyBillingTeamMember = (Maybe UUID, Maybe UUID)

selectGalleyBillingTeamMember :: PrepQuery R (Identity (TeamId)) RowGalleyBillingTeamMember
selectGalleyBillingTeamMember = "SELECT team, user FROM billing_team_member WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyBillingTeamMember :: Env -> TeamId -> IO [RowGalleyBillingTeamMember]
readGalleyBillingTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyBillingTeamMember (params Quorum (pure (tid))))

readGalleyBillingTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyBillingTeamMember] IO ()
readGalleyBillingTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyBillingTeamMember (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyBillingTeamMemberAll :: PrepQuery R () RowGalleyBillingTeamMember
selectGalleyBillingTeamMemberAll = "SELECT team, user FROM billing_team_member"

readGalleyBillingTeamMemberConduitAll :: Env -> ConduitM () [RowGalleyBillingTeamMember] IO ()
readGalleyBillingTeamMemberConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyBillingTeamMemberAll (paramsP Quorum () envPageSize) x5

insertGalleyBillingTeamMember :: Env -> FilePath -> IO ()
insertGalleyBillingTeamMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyBillingTeamMember';
  -- run Client action on each.
  pure ()

-- galley.clients

type RowGalleyClients = (Maybe UUID, Maybe (Cassandra.Set Text))

selectGalleyClients :: PrepQuery R (Identity ([UserId])) RowGalleyClients
selectGalleyClients = "SELECT user, clients FROM clients WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyClients :: Env -> [UserId] -> IO [RowGalleyClients]
readGalleyClients Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyClients (params Quorum (pure (uids))))

readGalleyClientsConduit :: Env -> [UserId] -> ConduitM () [RowGalleyClients] IO ()
readGalleyClientsConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyClients (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyClientsAll :: PrepQuery R () RowGalleyClients
selectGalleyClientsAll = "SELECT user, clients FROM clients"

readGalleyClientsConduitAll :: Env -> ConduitM () [RowGalleyClients] IO ()
readGalleyClientsConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyClientsAll (paramsP Quorum () envPageSize) x5

insertGalleyClients :: Env -> FilePath -> IO ()
insertGalleyClients _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyClients';
  -- run Client action on each.
  pure ()

-- galley.conversation

type RowGalleyConversation = (Maybe UUID, Maybe (Cassandra.Set Int32), Maybe Int32, Maybe UUID, Maybe Bool, Maybe Int64, Maybe Text, Maybe Int32, Maybe UUID, Maybe Int32)

selectGalleyConversation :: PrepQuery R (Identity ([ConvId])) RowGalleyConversation
selectGalleyConversation = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation WHERE conv in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyConversation :: Env -> [ConvId] -> IO [RowGalleyConversation]
readGalleyConversation Env {..} cids =
  runClient envGalley $
    retry x1 (query selectGalleyConversation (params Quorum (pure (cids))))

readGalleyConversationConduit :: Env -> [ConvId] -> ConduitM () [RowGalleyConversation] IO ()
readGalleyConversationConduit Env {..} cids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyConversation (paramsP Quorum (pure cids) envPageSize) x5

selectGalleyConversationAll :: PrepQuery R () RowGalleyConversation
selectGalleyConversationAll = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation"

readGalleyConversationConduitAll :: Env -> ConduitM () [RowGalleyConversation] IO ()
readGalleyConversationConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyConversationAll (paramsP Quorum () envPageSize) x5

insertGalleyConversation :: Env -> FilePath -> IO ()
insertGalleyConversation _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyConversation';
  -- run Client action on each.
  pure ()

-- galley.member

type RowGalleyMember = (Maybe UUID, Maybe UUID, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Int32, Maybe UUID, Maybe UUID, Maybe Int32, Maybe Text, Maybe UUID)

selectGalleyMember :: PrepQuery R (Identity ([ConvId])) RowGalleyMember
selectGalleyMember = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member WHERE conv in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyMember :: Env -> [ConvId] -> IO [RowGalleyMember]
readGalleyMember Env {..} cids =
  runClient envGalley $
    retry x1 (query selectGalleyMember (params Quorum (pure (cids))))

readGalleyMemberConduit :: Env -> [ConvId] -> ConduitM () [RowGalleyMember] IO ()
readGalleyMemberConduit Env {..} cids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyMember (paramsP Quorum (pure cids) envPageSize) x5

selectGalleyMemberAll :: PrepQuery R () RowGalleyMember
selectGalleyMemberAll = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member"

readGalleyMemberConduitAll :: Env -> ConduitM () [RowGalleyMember] IO ()
readGalleyMemberConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyMemberAll (paramsP Quorum () envPageSize) x5

insertGalleyMember :: Env -> FilePath -> IO ()
insertGalleyMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyMember';
  -- run Client action on each.
  pure ()

-- galley.team

type RowGalleyTeam = (Maybe UUID, Maybe Bool, Maybe UUID, Maybe Bool, Maybe Text, Maybe Text, Maybe Text, Maybe Int32, Maybe Int32)

selectGalleyTeam :: PrepQuery R (Identity (TeamId)) RowGalleyTeam
selectGalleyTeam = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeam :: Env -> TeamId -> IO [RowGalleyTeam]
readGalleyTeam Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeam (params Quorum (pure (tid))))

readGalleyTeamConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeam] IO ()
readGalleyTeamConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeam (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamAll :: PrepQuery R () RowGalleyTeam
selectGalleyTeamAll = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team"

readGalleyTeamConduitAll :: Env -> ConduitM () [RowGalleyTeam] IO ()
readGalleyTeamConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamAll (paramsP Quorum () envPageSize) x5

insertGalleyTeam :: Env -> FilePath -> IO ()
insertGalleyTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeam';
  -- run Client action on each.
  pure ()

-- galley.team_conv

type RowGalleyTeamConv = (Maybe UUID, Maybe UUID, Maybe Bool)

selectGalleyTeamConv :: PrepQuery R (Identity (TeamId)) RowGalleyTeamConv
selectGalleyTeamConv = "SELECT team, conv, managed FROM team_conv WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamConv :: Env -> TeamId -> IO [RowGalleyTeamConv]
readGalleyTeamConv Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamConv (params Quorum (pure (tid))))

readGalleyTeamConvConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamConv] IO ()
readGalleyTeamConvConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamConv (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamConvAll :: PrepQuery R () RowGalleyTeamConv
selectGalleyTeamConvAll = "SELECT team, conv, managed FROM team_conv"

readGalleyTeamConvConduitAll :: Env -> ConduitM () [RowGalleyTeamConv] IO ()
readGalleyTeamConvConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamConvAll (paramsP Quorum () envPageSize) x5

insertGalleyTeamConv :: Env -> FilePath -> IO ()
insertGalleyTeamConv _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamConv';
  -- run Client action on each.
  pure ()

-- galley.team_features

type RowGalleyTeamFeatures = (Maybe UUID, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32)

selectGalleyTeamFeatures :: PrepQuery R (Identity (TeamId)) RowGalleyTeamFeatures
selectGalleyTeamFeatures = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features WHERE team_id = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamFeatures :: Env -> TeamId -> IO [RowGalleyTeamFeatures]
readGalleyTeamFeatures Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamFeatures (params Quorum (pure (tid))))

readGalleyTeamFeaturesConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamFeatures] IO ()
readGalleyTeamFeaturesConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamFeatures (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamFeaturesAll :: PrepQuery R () RowGalleyTeamFeatures
selectGalleyTeamFeaturesAll = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features"

readGalleyTeamFeaturesConduitAll :: Env -> ConduitM () [RowGalleyTeamFeatures] IO ()
readGalleyTeamFeaturesConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamFeaturesAll (paramsP Quorum () envPageSize) x5

insertGalleyTeamFeatures :: Env -> FilePath -> IO ()
insertGalleyTeamFeatures _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamFeatures';
  -- run Client action on each.
  pure ()

-- galley.team_member

type RowGalleyTeamMember = (Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe UUID, Maybe Int32, Maybe Permissions)

selectGalleyTeamMember :: PrepQuery R (Identity (TeamId)) RowGalleyTeamMember
selectGalleyTeamMember = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamMember :: Env -> TeamId -> IO [RowGalleyTeamMember]
readGalleyTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamMember (params Quorum (pure (tid))))

readGalleyTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamMember] IO ()
readGalleyTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamMember (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamMemberAll :: PrepQuery R () RowGalleyTeamMember
selectGalleyTeamMemberAll = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member"

readGalleyTeamMemberConduitAll :: Env -> ConduitM () [RowGalleyTeamMember] IO ()
readGalleyTeamMemberConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamMemberAll (paramsP Quorum () envPageSize) x5

insertGalleyTeamMember :: Env -> FilePath -> IO ()
insertGalleyTeamMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamMember';
  -- run Client action on each.
  pure ()

-- galley.team_notifications

type RowGalleyTeamNotifications = (Maybe UUID, Maybe TimeUuid, Maybe Blob)

selectGalleyTeamNotifications :: PrepQuery R (Identity (TeamId)) RowGalleyTeamNotifications
selectGalleyTeamNotifications = "SELECT team, id, payload FROM team_notifications WHERE team = ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyTeamNotifications :: Env -> TeamId -> IO [RowGalleyTeamNotifications]
readGalleyTeamNotifications Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamNotifications (params Quorum (pure (tid))))

readGalleyTeamNotificationsConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamNotifications] IO ()
readGalleyTeamNotificationsConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamNotifications (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamNotificationsAll :: PrepQuery R () RowGalleyTeamNotifications
selectGalleyTeamNotificationsAll = "SELECT team, id, payload FROM team_notifications"

readGalleyTeamNotificationsConduitAll :: Env -> ConduitM () [RowGalleyTeamNotifications] IO ()
readGalleyTeamNotificationsConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamNotificationsAll (paramsP Quorum () envPageSize) x5

insertGalleyTeamNotifications :: Env -> FilePath -> IO ()
insertGalleyTeamNotifications _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamNotifications';
  -- run Client action on each.
  pure ()

-- galley.user

type RowGalleyUser = (Maybe UUID, Maybe UUID, Maybe Text, Maybe UUID)

selectGalleyUser :: PrepQuery R (Identity ([UserId])) RowGalleyUser
selectGalleyUser = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyUser :: Env -> [UserId] -> IO [RowGalleyUser]
readGalleyUser Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUser (params Quorum (pure (uids))))

readGalleyUserConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUser] IO ()
readGalleyUserConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUser (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyUserAll :: PrepQuery R () RowGalleyUser
selectGalleyUserAll = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user"

readGalleyUserConduitAll :: Env -> ConduitM () [RowGalleyUser] IO ()
readGalleyUserConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserAll (paramsP Quorum () envPageSize) x5

insertGalleyUser :: Env -> FilePath -> IO ()
insertGalleyUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyUser';
  -- run Client action on each.
  pure ()

-- galley.user_team

type RowGalleyUserTeam = (Maybe UUID, Maybe UUID)

selectGalleyUserTeam :: PrepQuery R (Identity ([UserId])) RowGalleyUserTeam
selectGalleyUserTeam = "SELECT user, team FROM user_team WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGalleyUserTeam :: Env -> [UserId] -> IO [RowGalleyUserTeam]
readGalleyUserTeam Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUserTeam (params Quorum (pure (uids))))

readGalleyUserTeamConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUserTeam] IO ()
readGalleyUserTeamConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserTeam (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyUserTeamAll :: PrepQuery R () RowGalleyUserTeam
selectGalleyUserTeamAll = "SELECT user, team FROM user_team"

readGalleyUserTeamConduitAll :: Env -> ConduitM () [RowGalleyUserTeam] IO ()
readGalleyUserTeamConduitAll Env {..} =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserTeamAll (paramsP Quorum () envPageSize) x5

insertGalleyUserTeam :: Env -> FilePath -> IO ()
insertGalleyUserTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyUserTeam';
  -- run Client action on each.
  pure ()

-- gundeck.notifications

type RowGundeckNotifications = (Maybe UUID, Maybe TimeUuid, Maybe (Cassandra.Set Text), Maybe Blob)

selectGundeckNotifications :: PrepQuery R (Identity ([UserId])) RowGundeckNotifications
selectGundeckNotifications = "SELECT user, id, clients, payload FROM notifications WHERE user in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readGundeckNotifications :: Env -> [UserId] -> IO [RowGundeckNotifications]
readGundeckNotifications Env {..} uids =
  runClient envGundeck $
    retry x1 (query selectGundeckNotifications (params Quorum (pure (uids))))

readGundeckNotificationsConduit :: Env -> [UserId] -> ConduitM () [RowGundeckNotifications] IO ()
readGundeckNotificationsConduit Env {..} uids =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckNotifications (paramsP Quorum (pure uids) envPageSize) x5

selectGundeckNotificationsAll :: PrepQuery R () RowGundeckNotifications
selectGundeckNotificationsAll = "SELECT user, id, clients, payload FROM notifications"

readGundeckNotificationsConduitAll :: Env -> ConduitM () [RowGundeckNotifications] IO ()
readGundeckNotificationsConduitAll Env {..} =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckNotificationsAll (paramsP Quorum () envPageSize) x5

insertGundeckNotifications :: Env -> FilePath -> IO ()
insertGundeckNotifications _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGundeckNotifications';
  -- run Client action on each.
  pure ()

-- spar.scim_user_times

type RowSparScimUserTimes = (Maybe UUID, Maybe UTCTime, Maybe UTCTime)

selectSparScimUserTimes :: PrepQuery R (Identity ([UserId])) RowSparScimUserTimes
selectSparScimUserTimes = "SELECT uid, created_at, last_updated_at FROM scim_user_times WHERE uid in ?"

-- TODO: remove and only use conduit version. even with test data (100MB) fetching without pagination fails
readSparScimUserTimes :: Env -> [UserId] -> IO [RowSparScimUserTimes]
readSparScimUserTimes Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparScimUserTimes (params Quorum (pure (uids))))

readSparScimUserTimesConduit :: Env -> [UserId] -> ConduitM () [RowSparScimUserTimes] IO ()
readSparScimUserTimesConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparScimUserTimes (paramsP Quorum (pure uids) envPageSize) x5

selectSparScimUserTimesAll :: PrepQuery R () RowSparScimUserTimes
selectSparScimUserTimesAll = "SELECT uid, created_at, last_updated_at FROM scim_user_times"

readSparScimUserTimesConduitAll :: Env -> ConduitM () [RowSparScimUserTimes] IO ()
readSparScimUserTimesConduitAll Env {..} =
  transPipe (runClient envSpar) $
    paginateC selectSparScimUserTimesAll (paramsP Quorum () envPageSize) x5

insertSparScimUserTimes :: Env -> FilePath -> IO ()
insertSparScimUserTimes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparScimUserTimes';
  -- run Client action on each.
  pure ()

insertAllTables :: Env -> IO ()
insertAllTables env = do
  insertBrigClients env "brig.clients"
  insertBrigConnection env "brig.connection"
  insertBrigIdMapping env "brig.id_mapping"
  insertBrigLoginCodes env "brig.login_codes"
  insertBrigPasswordReset env "brig.password_reset"
  insertBrigPrekeys env "brig.prekeys"
  insertBrigProperties env "brig.properties"
  insertBrigRichInfo env "brig.rich_info"
  insertBrigUser env "brig.user"
  insertBrigUserHandle env "brig.user_handle"
  insertGalleyBillingTeamMember env "galley.billing_team_member"
  insertGalleyClients env "galley.clients"
  insertGalleyConversation env "galley.conversation"
  insertGalleyMember env "galley.member"
  insertGalleyTeam env "galley.team"
  insertGalleyTeamConv env "galley.team_conv"
  insertGalleyTeamFeatures env "galley.team_features"
  insertGalleyTeamMember env "galley.team_member"
  insertGalleyTeamNotifications env "galley.team_notifications"
  insertGalleyUser env "galley.user"
  insertGalleyUserTeam env "galley.user_team"
  insertGundeckNotifications env "gundeck.notifications"
  insertSparScimUserTimes env "spar.scim_user_times"
