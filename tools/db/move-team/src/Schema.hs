{-# LANGUAGE RecordWildCards #-}

-- This file is part of the Wire Server implementation.
--
-- Copyright (C) 2020 Wire Swiss GmbH <opensource@wire.com>
--
-- This program is free software: you can redistribute it and/or modify it under
-- the terms of the GNU Affero General Public License as published by the Free
-- Software Foundation, either version 3 of the License, or (at your option) any
-- later version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
-- details.
--
-- You should have received a copy of the GNU Affero General Public License along
-- with this program. If not, see <https://www.gnu.org/licenses/>.

module Schema where

import Cassandra
import Data.Conduit
import Data.Handle (Handle)
import Data.IP (IP)
import Data.Id
import Data.Time
import Data.UUID
import Galley.Data.Instances ()
import Imports
import Types
import Wire.API.Team.Permission
import Wire.API.User.Password (PasswordResetKey)

-- This file was autogenerated by gen-table-types

-- brig.clients

type RowBrigClients = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text, Maybe IP, Maybe Text, Maybe Double, Maybe Double, Maybe Text, Maybe UTCTime, Maybe Int32)

selectBrigClients :: PrepQuery R (Identity ([UserId])) RowBrigClients
selectBrigClients = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients WHERE user in ?"

readBrigClients :: Env -> [UserId] -> IO [RowBrigClients]
readBrigClients Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigClients (params Quorum (pure (uids))))

readBrigClientsConduit :: Env -> [UserId] -> ConduitM () [RowBrigClients] IO ()
readBrigClientsConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigClients (paramsP Quorum (pure uids) envPageSize) x5

selectBrigClientsAll :: PrepQuery R () RowBrigClients
selectBrigClientsAll = "SELECT user, client, class, cookie, ip, label, lat, lon, model, tstamp, type FROM clients"

readBrigClientsAll :: Env -> IO [RowBrigClients]
readBrigClientsAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigClientsAll (params Quorum ()))

insertBrigClients :: Env -> FilePath -> IO ()
insertBrigClients _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigClients';
  -- run Client action on each.
  pure ()

-- brig.connection

type RowBrigConnection = (Maybe UUID, Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe Text, Maybe Int32)

selectBrigConnection :: PrepQuery R (Identity ([UserId])) RowBrigConnection
selectBrigConnection = "SELECT left, right, conv, last_update, message, status FROM connection WHERE left in ?"

readBrigConnection :: Env -> [UserId] -> IO [RowBrigConnection]
readBrigConnection Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigConnection (params Quorum (pure (uids))))

readBrigConnectionConduit :: Env -> [UserId] -> ConduitM () [RowBrigConnection] IO ()
readBrigConnectionConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigConnection (paramsP Quorum (pure uids) envPageSize) x5

selectBrigConnectionAll :: PrepQuery R () RowBrigConnection
selectBrigConnectionAll = "SELECT left, right, conv, last_update, message, status FROM connection"

readBrigConnectionAll :: Env -> IO [RowBrigConnection]
readBrigConnectionAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigConnectionAll (params Quorum ()))

insertBrigConnection :: Env -> FilePath -> IO ()
insertBrigConnection _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigConnection';
  -- run Client action on each.
  pure ()

-- brig.id_mapping

type RowBrigIdMapping = (Maybe UUID, Maybe Text, Maybe UUID)

selectBrigIdMapping :: PrepQuery R (Identity ([UserId])) RowBrigIdMapping
selectBrigIdMapping = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping WHERE mapped_id in ?"

readBrigIdMapping :: Env -> [UserId] -> IO [RowBrigIdMapping]
readBrigIdMapping Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigIdMapping (params Quorum (pure (uids))))

readBrigIdMappingConduit :: Env -> [UserId] -> ConduitM () [RowBrigIdMapping] IO ()
readBrigIdMappingConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigIdMapping (paramsP Quorum (pure uids) envPageSize) x5

selectBrigIdMappingAll :: PrepQuery R () RowBrigIdMapping
selectBrigIdMappingAll = "SELECT mapped_id, remote_domain, remote_id FROM id_mapping"

readBrigIdMappingAll :: Env -> IO [RowBrigIdMapping]
readBrigIdMappingAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigIdMappingAll (params Quorum ()))

insertBrigIdMapping :: Env -> FilePath -> IO ()
insertBrigIdMapping _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigIdMapping';
  -- run Client action on each.
  pure ()

-- brig.login_codes

type RowBrigLoginCodes = (Maybe UUID, Maybe Text, Maybe Int32, Maybe UTCTime)

selectBrigLoginCodes :: PrepQuery R (Identity ([UserId])) RowBrigLoginCodes
selectBrigLoginCodes = "SELECT user, code, retries, timeout FROM login_codes WHERE user in ?"

readBrigLoginCodes :: Env -> [UserId] -> IO [RowBrigLoginCodes]
readBrigLoginCodes Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigLoginCodes (params Quorum (pure (uids))))

readBrigLoginCodesConduit :: Env -> [UserId] -> ConduitM () [RowBrigLoginCodes] IO ()
readBrigLoginCodesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigLoginCodes (paramsP Quorum (pure uids) envPageSize) x5

selectBrigLoginCodesAll :: PrepQuery R () RowBrigLoginCodes
selectBrigLoginCodesAll = "SELECT user, code, retries, timeout FROM login_codes"

readBrigLoginCodesAll :: Env -> IO [RowBrigLoginCodes]
readBrigLoginCodesAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigLoginCodesAll (params Quorum ()))

insertBrigLoginCodes :: Env -> FilePath -> IO ()
insertBrigLoginCodes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigLoginCodes';
  -- run Client action on each.
  pure ()

-- brig.password_reset

type RowBrigPasswordReset = (Maybe Ascii, Maybe Ascii, Maybe Int32, Maybe UTCTime, Maybe UUID)

selectBrigPasswordReset :: PrepQuery R (Identity ([PasswordResetKey])) RowBrigPasswordReset
selectBrigPasswordReset = "SELECT key, code, retries, timeout, user FROM password_reset WHERE key in ?"

readBrigPasswordReset :: Env -> [PasswordResetKey] -> IO [RowBrigPasswordReset]
readBrigPasswordReset Env {..} reset_keys =
  runClient envBrig $
    retry x1 (query selectBrigPasswordReset (params Quorum (pure (reset_keys))))

readBrigPasswordResetConduit :: Env -> [PasswordResetKey] -> ConduitM () [RowBrigPasswordReset] IO ()
readBrigPasswordResetConduit Env {..} reset_keys =
  transPipe (runClient envBrig) $
    paginateC selectBrigPasswordReset (paramsP Quorum (pure reset_keys) envPageSize) x5

selectBrigPasswordResetAll :: PrepQuery R () RowBrigPasswordReset
selectBrigPasswordResetAll = "SELECT key, code, retries, timeout, user FROM password_reset"

readBrigPasswordResetAll :: Env -> IO [RowBrigPasswordReset]
readBrigPasswordResetAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigPasswordResetAll (params Quorum ()))

insertBrigPasswordReset :: Env -> FilePath -> IO ()
insertBrigPasswordReset _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigPasswordReset';
  -- run Client action on each.
  pure ()

-- brig.prekeys

type RowBrigPrekeys = (Maybe UUID, Maybe Text, Maybe Int32, Maybe Text)

selectBrigPrekeys :: PrepQuery R (Identity ([UserId])) RowBrigPrekeys
selectBrigPrekeys = "SELECT user, client, key, data FROM prekeys WHERE user in ?"

readBrigPrekeys :: Env -> [UserId] -> IO [RowBrigPrekeys]
readBrigPrekeys Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigPrekeys (params Quorum (pure (uids))))

readBrigPrekeysConduit :: Env -> [UserId] -> ConduitM () [RowBrigPrekeys] IO ()
readBrigPrekeysConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigPrekeys (paramsP Quorum (pure uids) envPageSize) x5

selectBrigPrekeysAll :: PrepQuery R () RowBrigPrekeys
selectBrigPrekeysAll = "SELECT user, client, key, data FROM prekeys"

readBrigPrekeysAll :: Env -> IO [RowBrigPrekeys]
readBrigPrekeysAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigPrekeysAll (params Quorum ()))

insertBrigPrekeys :: Env -> FilePath -> IO ()
insertBrigPrekeys _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigPrekeys';
  -- run Client action on each.
  pure ()

-- brig.properties

type RowBrigProperties = (Maybe UUID, Maybe Ascii, Maybe Blob)

selectBrigProperties :: PrepQuery R (Identity ([UserId])) RowBrigProperties
selectBrigProperties = "SELECT user, key, value FROM properties WHERE user in ?"

readBrigProperties :: Env -> [UserId] -> IO [RowBrigProperties]
readBrigProperties Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigProperties (params Quorum (pure (uids))))

readBrigPropertiesConduit :: Env -> [UserId] -> ConduitM () [RowBrigProperties] IO ()
readBrigPropertiesConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigProperties (paramsP Quorum (pure uids) envPageSize) x5

selectBrigPropertiesAll :: PrepQuery R () RowBrigProperties
selectBrigPropertiesAll = "SELECT user, key, value FROM properties"

readBrigPropertiesAll :: Env -> IO [RowBrigProperties]
readBrigPropertiesAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigPropertiesAll (params Quorum ()))

insertBrigProperties :: Env -> FilePath -> IO ()
insertBrigProperties _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigProperties';
  -- run Client action on each.
  pure ()

-- brig.rich_info

type RowBrigRichInfo = (Maybe UUID, Maybe Blob)

selectBrigRichInfo :: PrepQuery R (Identity ([UserId])) RowBrigRichInfo
selectBrigRichInfo = "SELECT user, json FROM rich_info WHERE user in ?"

readBrigRichInfo :: Env -> [UserId] -> IO [RowBrigRichInfo]
readBrigRichInfo Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigRichInfo (params Quorum (pure (uids))))

readBrigRichInfoConduit :: Env -> [UserId] -> ConduitM () [RowBrigRichInfo] IO ()
readBrigRichInfoConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigRichInfo (paramsP Quorum (pure uids) envPageSize) x5

selectBrigRichInfoAll :: PrepQuery R () RowBrigRichInfo
selectBrigRichInfoAll = "SELECT user, json FROM rich_info"

readBrigRichInfoAll :: Env -> IO [RowBrigRichInfo]
readBrigRichInfoAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigRichInfoAll (params Quorum ()))

insertBrigRichInfo :: Env -> FilePath -> IO ()
insertBrigRichInfo _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigRichInfo';
  -- run Client action on each.
  pure ()

-- brig.user

type RowBrigUser = (Maybe UUID, Maybe [Float], Maybe Int32, Maybe Bool, Maybe [AssetIgnoreData], Maybe Ascii, Maybe Text, Maybe UTCTime, Maybe Text, Maybe Ascii, Maybe Int32, Maybe Text, Maybe Blob, Maybe Text, Maybe [Blob], Maybe UUID, Maybe Bool, Maybe UUID, Maybe Text, Maybe Int32, Maybe UUID)

selectBrigUser :: PrepQuery R (Identity ([UserId])) RowBrigUser
selectBrigUser = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user WHERE id in ?"

readBrigUser :: Env -> [UserId] -> IO [RowBrigUser]
readBrigUser Env {..} uids =
  runClient envBrig $
    retry x1 (query selectBrigUser (params Quorum (pure (uids))))

readBrigUserConduit :: Env -> [UserId] -> ConduitM () [RowBrigUser] IO ()
readBrigUserConduit Env {..} uids =
  transPipe (runClient envBrig) $
    paginateC selectBrigUser (paramsP Quorum (pure uids) envPageSize) x5

selectBrigUserAll :: PrepQuery R () RowBrigUser
selectBrigUserAll = "SELECT id, accent, accent_id, activated, assets, country, email, expires, handle, language, managed_by, name, password, phone, picture, provider, searchable, service, sso_id, status, team FROM user"

readBrigUserAll :: Env -> IO [RowBrigUser]
readBrigUserAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigUserAll (params Quorum ()))

insertBrigUser :: Env -> FilePath -> IO ()
insertBrigUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUser';
  -- run Client action on each.
  pure ()

-- brig.user_handle

type RowBrigUserHandle = (Maybe Text, Maybe UUID)

selectBrigUserHandle :: PrepQuery R (Identity ([Handle])) RowBrigUserHandle
selectBrigUserHandle = "SELECT handle, user FROM user_handle WHERE handle in ?"

readBrigUserHandle :: Env -> [Handle] -> IO [RowBrigUserHandle]
readBrigUserHandle Env {..} handles =
  runClient envBrig $
    retry x1 (query selectBrigUserHandle (params Quorum (pure (handles))))

readBrigUserHandleConduit :: Env -> [Handle] -> ConduitM () [RowBrigUserHandle] IO ()
readBrigUserHandleConduit Env {..} handles =
  transPipe (runClient envBrig) $
    paginateC selectBrigUserHandle (paramsP Quorum (pure handles) envPageSize) x5

selectBrigUserHandleAll :: PrepQuery R () RowBrigUserHandle
selectBrigUserHandleAll = "SELECT handle, user FROM user_handle"

readBrigUserHandleAll :: Env -> IO [RowBrigUserHandle]
readBrigUserHandleAll Env {..} =
  runClient envBrig $
    retry x1 (query selectBrigUserHandleAll (params Quorum ()))

insertBrigUserHandle :: Env -> FilePath -> IO ()
insertBrigUserHandle _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowBrigUserHandle';
  -- run Client action on each.
  pure ()

-- galley.billing_team_member

type RowGalleyBillingTeamMember = (Maybe UUID, Maybe UUID)

selectGalleyBillingTeamMember :: PrepQuery R (Identity (TeamId)) RowGalleyBillingTeamMember
selectGalleyBillingTeamMember = "SELECT team, user FROM billing_team_member WHERE team = ?"

readGalleyBillingTeamMember :: Env -> TeamId -> IO [RowGalleyBillingTeamMember]
readGalleyBillingTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyBillingTeamMember (params Quorum (pure (tid))))

readGalleyBillingTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyBillingTeamMember] IO ()
readGalleyBillingTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyBillingTeamMember (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyBillingTeamMemberAll :: PrepQuery R () RowGalleyBillingTeamMember
selectGalleyBillingTeamMemberAll = "SELECT team, user FROM billing_team_member"

readGalleyBillingTeamMemberAll :: Env -> IO [RowGalleyBillingTeamMember]
readGalleyBillingTeamMemberAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyBillingTeamMemberAll (params Quorum ()))

insertGalleyBillingTeamMember :: Env -> FilePath -> IO ()
insertGalleyBillingTeamMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyBillingTeamMember';
  -- run Client action on each.
  pure ()

-- galley.clients

type RowGalleyClients = (Maybe UUID, Maybe (Cassandra.Set Text))

selectGalleyClients :: PrepQuery R (Identity ([UserId])) RowGalleyClients
selectGalleyClients = "SELECT user, clients FROM clients WHERE user in ?"

readGalleyClients :: Env -> [UserId] -> IO [RowGalleyClients]
readGalleyClients Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyClients (params Quorum (pure (uids))))

readGalleyClientsConduit :: Env -> [UserId] -> ConduitM () [RowGalleyClients] IO ()
readGalleyClientsConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyClients (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyClientsAll :: PrepQuery R () RowGalleyClients
selectGalleyClientsAll = "SELECT user, clients FROM clients"

readGalleyClientsAll :: Env -> IO [RowGalleyClients]
readGalleyClientsAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyClientsAll (params Quorum ()))

insertGalleyClients :: Env -> FilePath -> IO ()
insertGalleyClients _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyClients';
  -- run Client action on each.
  pure ()

-- galley.conversation

type RowGalleyConversation = (Maybe UUID, Maybe (Cassandra.Set Int32), Maybe Int32, Maybe UUID, Maybe Bool, Maybe Integer, Maybe Text, Maybe Int32, Maybe UUID, Maybe Int32)

selectGalleyConversation :: PrepQuery R (Identity ([ConvId])) RowGalleyConversation
selectGalleyConversation = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation WHERE conv in ?"

readGalleyConversation :: Env -> [ConvId] -> IO [RowGalleyConversation]
readGalleyConversation Env {..} cids =
  runClient envGalley $
    retry x1 (query selectGalleyConversation (params Quorum (pure (cids))))

readGalleyConversationConduit :: Env -> [ConvId] -> ConduitM () [RowGalleyConversation] IO ()
readGalleyConversationConduit Env {..} cids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyConversation (paramsP Quorum (pure cids) envPageSize) x5

selectGalleyConversationAll :: PrepQuery R () RowGalleyConversation
selectGalleyConversationAll = "SELECT conv, access, access_role, creator, deleted, message_timer, name, receipt_mode, team, type FROM conversation"

readGalleyConversationAll :: Env -> IO [RowGalleyConversation]
readGalleyConversationAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyConversationAll (params Quorum ()))

insertGalleyConversation :: Env -> FilePath -> IO ()
insertGalleyConversation _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyConversation';
  -- run Client action on each.
  pure ()

-- galley.member

type RowGalleyMember = (Maybe UUID, Maybe UUID, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Bool, Maybe Text, Maybe Int32, Maybe UUID, Maybe UUID, Maybe Int32, Maybe Text, Maybe UUID)

selectGalleyMember :: PrepQuery R (Identity ([ConvId])) RowGalleyMember
selectGalleyMember = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member WHERE conv in ?"

readGalleyMember :: Env -> [ConvId] -> IO [RowGalleyMember]
readGalleyMember Env {..} cids =
  runClient envGalley $
    retry x1 (query selectGalleyMember (params Quorum (pure (cids))))

readGalleyMemberConduit :: Env -> [ConvId] -> ConduitM () [RowGalleyMember] IO ()
readGalleyMemberConduit Env {..} cids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyMember (paramsP Quorum (pure cids) envPageSize) x5

selectGalleyMemberAll :: PrepQuery R () RowGalleyMember
selectGalleyMemberAll = "SELECT conv, user, conversation_role, hidden, hidden_ref, otr_archived, otr_archived_ref, otr_muted, otr_muted_ref, otr_muted_status, provider, service, status, user_remote_domain, user_remote_id FROM member"

readGalleyMemberAll :: Env -> IO [RowGalleyMember]
readGalleyMemberAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyMemberAll (params Quorum ()))

insertGalleyMember :: Env -> FilePath -> IO ()
insertGalleyMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyMember';
  -- run Client action on each.
  pure ()

-- galley.team

type RowGalleyTeam = (Maybe UUID, Maybe Bool, Maybe UUID, Maybe Bool, Maybe Text, Maybe Text, Maybe Text, Maybe Int32, Maybe Int32)

selectGalleyTeam :: PrepQuery R (Identity (TeamId)) RowGalleyTeam
selectGalleyTeam = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team WHERE team = ?"

readGalleyTeam :: Env -> TeamId -> IO [RowGalleyTeam]
readGalleyTeam Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeam (params Quorum (pure (tid))))

readGalleyTeamConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeam] IO ()
readGalleyTeamConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeam (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamAll :: PrepQuery R () RowGalleyTeam
selectGalleyTeamAll = "SELECT team, binding, creator, deleted, icon, icon_key, name, search_visibility, status FROM team"

readGalleyTeamAll :: Env -> IO [RowGalleyTeam]
readGalleyTeamAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyTeamAll (params Quorum ()))

insertGalleyTeam :: Env -> FilePath -> IO ()
insertGalleyTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeam';
  -- run Client action on each.
  pure ()

-- galley.team_conv

type RowGalleyTeamConv = (Maybe UUID, Maybe UUID, Maybe Bool)

selectGalleyTeamConv :: PrepQuery R (Identity (TeamId)) RowGalleyTeamConv
selectGalleyTeamConv = "SELECT team, conv, managed FROM team_conv WHERE team = ?"

readGalleyTeamConv :: Env -> TeamId -> IO [RowGalleyTeamConv]
readGalleyTeamConv Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamConv (params Quorum (pure (tid))))

readGalleyTeamConvConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamConv] IO ()
readGalleyTeamConvConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamConv (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamConvAll :: PrepQuery R () RowGalleyTeamConv
selectGalleyTeamConvAll = "SELECT team, conv, managed FROM team_conv"

readGalleyTeamConvAll :: Env -> IO [RowGalleyTeamConv]
readGalleyTeamConvAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyTeamConvAll (params Quorum ()))

insertGalleyTeamConv :: Env -> FilePath -> IO ()
insertGalleyTeamConv _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamConv';
  -- run Client action on each.
  pure ()

-- galley.team_features

type RowGalleyTeamFeatures = (Maybe UUID, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32, Maybe Int32)

selectGalleyTeamFeatures :: PrepQuery R (Identity (TeamId)) RowGalleyTeamFeatures
selectGalleyTeamFeatures = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features WHERE team_id = ?"

readGalleyTeamFeatures :: Env -> TeamId -> IO [RowGalleyTeamFeatures]
readGalleyTeamFeatures Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamFeatures (params Quorum (pure (tid))))

readGalleyTeamFeaturesConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamFeatures] IO ()
readGalleyTeamFeaturesConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamFeatures (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamFeaturesAll :: PrepQuery R () RowGalleyTeamFeatures
selectGalleyTeamFeaturesAll = "SELECT team_id, digital_signatures, legalhold_status, search_visibility_status, sso_status, validate_saml_emails FROM team_features"

readGalleyTeamFeaturesAll :: Env -> IO [RowGalleyTeamFeatures]
readGalleyTeamFeaturesAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyTeamFeaturesAll (params Quorum ()))

insertGalleyTeamFeatures :: Env -> FilePath -> IO ()
insertGalleyTeamFeatures _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamFeatures';
  -- run Client action on each.
  pure ()

-- galley.team_member

type RowGalleyTeamMember = (Maybe UUID, Maybe UUID, Maybe UTCTime, Maybe UUID, Maybe Int32, Maybe Permissions)

selectGalleyTeamMember :: PrepQuery R (Identity (TeamId)) RowGalleyTeamMember
selectGalleyTeamMember = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member WHERE team = ?"

readGalleyTeamMember :: Env -> TeamId -> IO [RowGalleyTeamMember]
readGalleyTeamMember Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamMember (params Quorum (pure (tid))))

readGalleyTeamMemberConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamMember] IO ()
readGalleyTeamMemberConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamMember (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamMemberAll :: PrepQuery R () RowGalleyTeamMember
selectGalleyTeamMemberAll = "SELECT team, user, invited_at, invited_by, legalhold_status, perms FROM team_member"

readGalleyTeamMemberAll :: Env -> IO [RowGalleyTeamMember]
readGalleyTeamMemberAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyTeamMemberAll (params Quorum ()))

insertGalleyTeamMember :: Env -> FilePath -> IO ()
insertGalleyTeamMember _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamMember';
  -- run Client action on each.
  pure ()

-- galley.team_notifications

type RowGalleyTeamNotifications = (Maybe UUID, Maybe UUID, Maybe Blob)

selectGalleyTeamNotifications :: PrepQuery R (Identity (TeamId)) RowGalleyTeamNotifications
selectGalleyTeamNotifications = "SELECT team, id, payload FROM team_notifications WHERE team = ?"

readGalleyTeamNotifications :: Env -> TeamId -> IO [RowGalleyTeamNotifications]
readGalleyTeamNotifications Env {..} tid =
  runClient envGalley $
    retry x1 (query selectGalleyTeamNotifications (params Quorum (pure (tid))))

readGalleyTeamNotificationsConduit :: Env -> TeamId -> ConduitM () [RowGalleyTeamNotifications] IO ()
readGalleyTeamNotificationsConduit Env {..} tid =
  transPipe (runClient envGalley) $
    paginateC selectGalleyTeamNotifications (paramsP Quorum (pure tid) envPageSize) x5

selectGalleyTeamNotificationsAll :: PrepQuery R () RowGalleyTeamNotifications
selectGalleyTeamNotificationsAll = "SELECT team, id, payload FROM team_notifications"

readGalleyTeamNotificationsAll :: Env -> IO [RowGalleyTeamNotifications]
readGalleyTeamNotificationsAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyTeamNotificationsAll (params Quorum ()))

insertGalleyTeamNotifications :: Env -> FilePath -> IO ()
insertGalleyTeamNotifications _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyTeamNotifications';
  -- run Client action on each.
  pure ()

-- galley.user

type RowGalleyUser = (Maybe UUID, Maybe UUID, Maybe Text, Maybe UUID)

selectGalleyUser :: PrepQuery R (Identity ([UserId])) RowGalleyUser
selectGalleyUser = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user WHERE user in ?"

readGalleyUser :: Env -> [UserId] -> IO [RowGalleyUser]
readGalleyUser Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUser (params Quorum (pure (uids))))

readGalleyUserConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUser] IO ()
readGalleyUserConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUser (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyUserAll :: PrepQuery R () RowGalleyUser
selectGalleyUserAll = "SELECT user, conv, conv_remote_domain, conv_remote_id FROM user"

readGalleyUserAll :: Env -> IO [RowGalleyUser]
readGalleyUserAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyUserAll (params Quorum ()))

insertGalleyUser :: Env -> FilePath -> IO ()
insertGalleyUser _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyUser';
  -- run Client action on each.
  pure ()

-- galley.user_team

type RowGalleyUserTeam = (Maybe UUID, Maybe UUID)

selectGalleyUserTeam :: PrepQuery R (Identity ([UserId])) RowGalleyUserTeam
selectGalleyUserTeam = "SELECT user, team FROM user_team WHERE user in ?"

readGalleyUserTeam :: Env -> [UserId] -> IO [RowGalleyUserTeam]
readGalleyUserTeam Env {..} uids =
  runClient envGalley $
    retry x1 (query selectGalleyUserTeam (params Quorum (pure (uids))))

readGalleyUserTeamConduit :: Env -> [UserId] -> ConduitM () [RowGalleyUserTeam] IO ()
readGalleyUserTeamConduit Env {..} uids =
  transPipe (runClient envGalley) $
    paginateC selectGalleyUserTeam (paramsP Quorum (pure uids) envPageSize) x5

selectGalleyUserTeamAll :: PrepQuery R () RowGalleyUserTeam
selectGalleyUserTeamAll = "SELECT user, team FROM user_team"

readGalleyUserTeamAll :: Env -> IO [RowGalleyUserTeam]
readGalleyUserTeamAll Env {..} =
  runClient envGalley $
    retry x1 (query selectGalleyUserTeamAll (params Quorum ()))

insertGalleyUserTeam :: Env -> FilePath -> IO ()
insertGalleyUserTeam _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGalleyUserTeam';
  -- run Client action on each.
  pure ()

-- gundeck.notifications

type RowGundeckNotifications = (Maybe UUID, Maybe UUID, Maybe (Cassandra.Set Text), Maybe Blob)

selectGundeckNotifications :: PrepQuery R (Identity ([UserId])) RowGundeckNotifications
selectGundeckNotifications = "SELECT user, id, clients, payload FROM notifications WHERE user in ?"

readGundeckNotifications :: Env -> [UserId] -> IO [RowGundeckNotifications]
readGundeckNotifications Env {..} uids =
  runClient envGundeck $
    retry x1 (query selectGundeckNotifications (params Quorum (pure (uids))))

readGundeckNotificationsConduit :: Env -> [UserId] -> ConduitM () [RowGundeckNotifications] IO ()
readGundeckNotificationsConduit Env {..} uids =
  transPipe (runClient envGundeck) $
    paginateC selectGundeckNotifications (paramsP Quorum (pure uids) envPageSize) x5

selectGundeckNotificationsAll :: PrepQuery R () RowGundeckNotifications
selectGundeckNotificationsAll = "SELECT user, id, clients, payload FROM notifications"

readGundeckNotificationsAll :: Env -> IO [RowGundeckNotifications]
readGundeckNotificationsAll Env {..} =
  runClient envGundeck $
    retry x1 (query selectGundeckNotificationsAll (params Quorum ()))

insertGundeckNotifications :: Env -> FilePath -> IO ()
insertGundeckNotifications _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowGundeckNotifications';
  -- run Client action on each.
  pure ()

-- spar.scim_user_times

type RowSparScimUserTimes = (Maybe UUID, Maybe UTCTime, Maybe UTCTime)

selectSparScimUserTimes :: PrepQuery R (Identity ([UserId])) RowSparScimUserTimes
selectSparScimUserTimes = "SELECT uid, created_at, last_updated_at FROM scim_user_times WHERE uid in ?"

readSparScimUserTimes :: Env -> [UserId] -> IO [RowSparScimUserTimes]
readSparScimUserTimes Env {..} uids =
  runClient envSpar $
    retry x1 (query selectSparScimUserTimes (params Quorum (pure (uids))))

readSparScimUserTimesConduit :: Env -> [UserId] -> ConduitM () [RowSparScimUserTimes] IO ()
readSparScimUserTimesConduit Env {..} uids =
  transPipe (runClient envSpar) $
    paginateC selectSparScimUserTimes (paramsP Quorum (pure uids) envPageSize) x5

selectSparScimUserTimesAll :: PrepQuery R () RowSparScimUserTimes
selectSparScimUserTimesAll = "SELECT uid, created_at, last_updated_at FROM scim_user_times"

readSparScimUserTimesAll :: Env -> IO [RowSparScimUserTimes]
readSparScimUserTimesAll Env {..} =
  runClient envSpar $
    retry x1 (query selectSparScimUserTimesAll (params Quorum ()))

insertSparScimUserTimes :: Env -> FilePath -> IO ()
insertSparScimUserTimes _ _ = do
  -- TODO:
  -- if file does not exist, do nothing.
  -- otherwise, read lines from file;
  -- parse each as 'RowSparScimUserTimes';
  -- run Client action on each.
  pure ()

insertAllTables :: Env -> IO ()
insertAllTables env = do
  insertBrigClients env "brig.clients"
  insertBrigConnection env "brig.connection"
  insertBrigIdMapping env "brig.id_mapping"
  insertBrigLoginCodes env "brig.login_codes"
  insertBrigPasswordReset env "brig.password_reset"
  insertBrigPrekeys env "brig.prekeys"
  insertBrigProperties env "brig.properties"
  insertBrigRichInfo env "brig.rich_info"
  insertBrigUser env "brig.user"
  insertBrigUserHandle env "brig.user_handle"
  insertGalleyBillingTeamMember env "galley.billing_team_member"
  insertGalleyClients env "galley.clients"
  insertGalleyConversation env "galley.conversation"
  insertGalleyMember env "galley.member"
  insertGalleyTeam env "galley.team"
  insertGalleyTeamConv env "galley.team_conv"
  insertGalleyTeamFeatures env "galley.team_features"
  insertGalleyTeamMember env "galley.team_member"
  insertGalleyTeamNotifications env "galley.team_notifications"
  insertGalleyUser env "galley.user"
  insertGalleyUserTeam env "galley.user_team"
  insertGundeckNotifications env "gundeck.notifications"
  insertSparScimUserTimes env "spar.scim_user_times"
